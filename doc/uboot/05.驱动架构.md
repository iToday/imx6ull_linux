<!-- TOC -->

- [简介](#%E7%AE%80%E4%BB%8B)
- [udevice](#udevice)
- [driver](#driver)
- [uclass](#uclass)
- [关系](#%E5%85%B3%E7%B3%BB)
- [实例分析](#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90)
    - [I2C](#i2c)
        - [驱动定义](#%E9%A9%B1%E5%8A%A8%E5%AE%9A%E4%B9%89)
        - [驱动加载](#%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD)
        - [驱动调用](#%E9%A9%B1%E5%8A%A8%E8%B0%83%E7%94%A8)
    - [RAM](#ram)
    - [NET](#net)

<!-- /TOC -->

# 简介
DM 是 U-Boot 中的驱动框架，全称 Driver Mode。

DM 有自己的三要素：udevice、uclass、driver。

udevice 描述具体的某一个硬件设备。

driver 是与这个设备匹配的驱动。

uclass 是同一类设备的抽象，提供管理同一类设备的抽象接口。

# udevice 
描述具体的某一个硬件设备。

		/**
		 * struct udevice - An instance of a driver
		 *
		 * 包含有关设备的信息，该设备是绑定到特定端口或外围设备的驱动程序（本质上是一个驱动程序实例）。

		 * 设备将通过“bind”调用出现，要么是由一个 U_BOOT_DRVINFO() 宏（在这种情况下 plat 是非空的）或设备树中的一个节点（在这种情况下 of_offset >= 0）。 
		 * 在后一种情况下，我们在驱动程序 of_to_plat 方法（如果设备具有设备树节点，则在探测方法之前调用）实现的函数中将设备树信息转换为 plat。

		 * plat, priv 和 uclass_priv 这三个都可以由驱动程序分配，也可以使用struct driver 和struct uclass_driver 的auto 成员让驱动程序模型自动分配。
		 *
		 * @driver: 设备对应的驱动
		 * @name: 设备名称，通常为FDT中节点名称
		 * @plat_: 设备配置数据
		 * @parent_plat_: 设备父总线的配置数据
		 * @uclass_plat_: 设备对应uclass的配置数据
		 * @driver_data: Driver data word for the entry that matched this device with its driver
		 * @parent: Parent of this device, or NULL for the top level device
		 * @priv_: Private data for this device (do not access outside driver model)
		 * @uclass: Pointer to uclass for this device
		 * @uclass_priv_: The uclass's private data for this device (do not access outside driver model)
		 * @parent_priv_: The parent's private data for this device (do not access outside driver model)
		 * @uclass_node: Used by uclass to link its devices
		 * @child_head: List of children of this device
		 * @sibling_node: Next device in list of all devices
		 * @flags_: Flags for this device DM_FLAG_... (do not access outside driver model)
		 * @seq_: Allocated sequence number for this device (-1 = none). This is set up
		 * when the device is bound and is unique within the device's uclass. If the
		 * device has an alias in the devicetree then that is used to set the sequence
		 * number. Otherwise, the next available number is used. Sequence numbers are
		 * used by certain commands that need device to be numbered (e.g. 'mmc dev').
		 * (do not access outside driver model)
		 * @node_: Reference to device tree node for this device (do not access outside
		 *	driver model)
		 * @devres_head: List of memory allocations associated with this device.
		 *		When CONFIG_DEVRES is enabled, devm_kmalloc() and friends will
		 *		add to this list. Memory so-allocated will be freed
		 *		automatically when the device is removed / unbound
		 * @dma_offset: Offset between the physical address space (CPU's) and the
		 *		device's bus address space
		 */
		struct udevice {
			const struct driver *driver;
			const char *name;
			void *plat_;
			void *parent_plat_;
			void *uclass_plat_;
			ulong driver_data;
			struct udevice *parent;
			void *priv_;
			struct uclass *uclass;
			void *uclass_priv_;
			void *parent_priv_;
			struct list_head uclass_node;
			struct list_head child_head;
			struct list_head sibling_node;
		#if !CONFIG_IS_ENABLED(OF_PLATDATA_RT)
			u32 flags_;
		#endif
			int seq_;
		#if !CONFIG_IS_ENABLED(OF_PLATDATA)
			ofnode node_;
		#endif
		#ifdef CONFIG_DEVRES
			struct list_head devres_head;
		#endif
		#if CONFIG_IS_ENABLED(DM_DMA)
			ulong dma_offset;
		#endif
		};


# driver 
与设备匹配的驱动。

		/**
		 * struct driver - A driver for a feature or peripheral
		 *
		 *	包含安装设备和删除设备的方法。
			设备需要信息来设置自己 - 这要么提供通过 plat 或设备树节点（我们通过查找与 of_match 匹配的兼容字符串来找到）。

			  驱动程序都属于一个 uclass，代表一个类的设备
			  同类型。 驱动程序的公共元素可以在 uclass 中实现，或者 uclass 可以为其中的驱动程序提供一致的接口。

		 * This holds methods for setting up a new device, and also removing it.
		 * The device needs information to set itself up - this is provided either
		 * by plat or a device tree node (which we find by looking up
		 * matching compatible strings with of_match).
		 *
		 * Drivers all belong to a uclass, representing a class of devices of the
		 * same type. Common elements of the drivers can be implemented in the uclass,
		 * or the uclass can provide a consistent interface to the drivers within
		 * it.
		 *
		 * @name: Device name
		 * @id: Identifies the uclass we belong to
		 * @of_match: List of compatible strings to match, and any identifying data
		 * for each.
		 * @bind: Called to bind a device to its driver
		 * @probe: Called to probe a device, i.e. activate it
		 * @remove: Called to remove a device, i.e. de-activate it
		 * @unbind: Called to unbind a device from its driver
		 * @of_to_plat: Called before probe to decode device tree data
		 * @child_post_bind: Called after a new child has been bound
		 * @child_pre_probe: Called before a child device is probed. The device has
		 * memory allocated but it has not yet been probed.
		 * @child_post_remove: Called after a child device is removed. The device
		 * has memory allocated but its device_remove() method has been called.
		 * @priv_auto: If non-zero this is the size of the private data
		 * to be allocated in the device's ->priv pointer. If zero, then the driver
		 * is responsible for allocating any data required.
		 * @plat_auto: If non-zero this is the size of the
		 * platform data to be allocated in the device's ->plat pointer.
		 * This is typically only useful for device-tree-aware drivers (those with
		 * an of_match), since drivers which use plat will have the data
		 * provided in the U_BOOT_DRVINFO() instantiation.
		 * @per_child_auto: Each device can hold private data owned by
		 * its parent. If required this will be automatically allocated if this
		 * value is non-zero.
		 * @per_child_plat_auto: A bus likes to store information about
		 * its children. If non-zero this is the size of this data, to be allocated
		 * in the child's parent_plat pointer.
		 * @ops: Driver-specific operations. This is typically a list of function
		 * pointers defined by the driver, to implement driver functions required by
		 * the uclass.
		 * @flags: driver flags - see DM_FLAGS_...
		 * @acpi_ops: Advanced Configuration and Power Interface (ACPI) operations,
		 * allowing the device to add things to the ACPI tables passed to Linux
		 */
		struct driver {
			char *name;
			enum uclass_id id;
			const struct udevice_id *of_match;
			int (*bind)(struct udevice *dev);
			int (*probe)(struct udevice *dev);
			int (*remove)(struct udevice *dev);
			int (*unbind)(struct udevice *dev);
			int (*of_to_plat)(struct udevice *dev);
			int (*child_post_bind)(struct udevice *dev);
			int (*child_pre_probe)(struct udevice *dev);
			int (*child_post_remove)(struct udevice *dev);
			int priv_auto;
			int plat_auto;
			int per_child_auto;
			int per_child_plat_auto;
			const void *ops;	/* driver-specific operations */
			uint32_t flags;
		#if CONFIG_IS_ENABLED(ACPIGEN)
			struct acpi_ops *acpi_ops;
		#endif
		};

		/* Declare a new U-Boot driver */
		#define U_BOOT_DRIVER(__name)						\
			ll_entry_declare(struct driver, __name, driver)


# uclass 
同一类设备的抽象，提供管理同一类设备的抽象接口。

		/**
		 * struct uclass - 一个 U-Boot 驱动类，将相似的驱动抽象
		 *
		 * uclass 为特定功能提供接口，该功能由一个或多个驱动程序实现。 每个驱动程序都属于一个 uclass，
		 * 即使它是该 uclass 中的唯一驱动程序。 一个示例 uclass 是 GPIO，它提供更改读取输入、设置和清除输出等的能力。

		 * 可能有片上 SoC GPIO 组、I2C GPIO 扩展器和 PMIC IO 线的驱动程序，所有这些都通过 uclass 以统一方式提供。
		 *
		 * @priv_: Private data for this uclass (do not access outside driver model)
		 * @uc_drv: The driver for the uclass itself, not to be confused with a
		 * 'struct driver'
		 * @dev_head: List of devices in this uclass (devices are attached to their
		 * uclass when their bind method is called)
		 * @sibling_node: Next uclass in the linked list of uclasses
		 */
		struct uclass {
			void *priv_;
			struct uclass_driver *uc_drv;
			struct list_head dev_head;
			struct list_head sibling_node;
		};



		/**
		 * struct uclass_driver - Driver for the uclass
		 *
		 * uclass_driver 为一组相关的驱动程序提供了一致的接口，接口抽象
		 *
		 * @name: Name of uclass driver
		 * @id: ID number of this uclass

		 * 一个uclass_driver有下面可实现的接口：

		 * @post_bind: Called after a new device is bound to this uclass
		 * @pre_unbind: Called before a device is unbound from this uclass
		 * @pre_probe: Called before a new device is probed
		 * @post_probe: Called after a new device is probed
		 * @pre_remove: Called before a device is removed
		 * @child_post_bind: Called after a child is bound to a device in this uclass
		 * @child_pre_probe: Called before a child in this uclass is probed
		 * @child_post_probe: Called after a child in this uclass is probed
		 * @init: Called to set up the uclass
		 * @destroy: Called to destroy the uclass

		 * @priv_auto: If non-zero this is the size of the private data
		 * to be allocated in the uclass's ->priv pointer. If zero, then the uclass
		 * driver is responsible for allocating any data required.
		 * @per_device_auto: Each device can hold private data owned
		 * by the uclass. If required this will be automatically allocated if this
		 * value is non-zero.
		 * @per_device_plat_auto: Each device can hold platform data
		 * owned by the uclass as 'dev->uclass_plat'. If the value is non-zero,
		 * then this will be automatically allocated.
		 * @per_child_auto: Each child device (of a parent in this
		 * uclass) can hold parent data for the device/uclass. This value is only
		 * used as a fallback if this member is 0 in the driver.
		 * @per_child_plat_auto: A bus likes to store information about
		 * its children. If non-zero this is the size of this data, to be allocated
		 * in the child device's parent_plat pointer. This value is only used as
		 * a fallback if this member is 0 in the driver.
		 * @flags: Flags for this uclass (DM_UC_...)
		 */
		struct uclass_driver {
			const char *name;
			enum uclass_id id;
			int (*post_bind)(struct udevice *dev);
			int (*pre_unbind)(struct udevice *dev);
			int (*pre_probe)(struct udevice *dev);
			int (*post_probe)(struct udevice *dev);
			int (*pre_remove)(struct udevice *dev);
			int (*child_post_bind)(struct udevice *dev);
			int (*child_pre_probe)(struct udevice *dev);
			int (*child_post_probe)(struct udevice *dev);
			int (*init)(struct uclass *class);
			int (*destroy)(struct uclass *class);
			int priv_auto;
			int per_device_auto;
			int per_device_plat_auto;
			int per_child_auto;
			int per_child_plat_auto;
			uint32_t flags;
		};

		/* Declare a new uclass_driver */
		#define UCLASS_DRIVER(__name)						\
			ll_entry_declare(struct uclass_driver, __name, uclass_driver)

		enum uclass_id {
			/* These are used internally by driver model */
			UCLASS_ROOT = 0,
			UCLASS_DEMO,
			UCLASS_TEST,
			UCLASS_TEST_FDT,
			UCLASS_TEST_FDT_MANUAL,
			UCLASS_TEST_BUS,
			UCLASS_TEST_PROBE,
			UCLASS_TEST_DUMMY,
			UCLASS_TEST_DEVRES,
			UCLASS_TEST_ACPI,
			UCLASS_SPI_EMUL,	/* sandbox SPI device emulator */
			UCLASS_I2C_EMUL,	/* sandbox I2C device emulator */
			UCLASS_I2C_EMUL_PARENT,	/* parent for I2C device emulators */
			UCLASS_PCI_EMUL,	/* sandbox PCI device emulator */
			UCLASS_PCI_EMUL_PARENT,	/* parent for PCI device emulators */
			UCLASS_USB_EMUL,	/* sandbox USB bus device emulator */
			UCLASS_AXI_EMUL,	/* sandbox AXI bus device emulator */

			/* U-Boot uclasses start here - in alphabetical order */
			UCLASS_ACPI_PMC,	/* (x86) Power-management controller (PMC) */
			UCLASS_ADC,		/* Analog-to-digital converter */
			UCLASS_AHCI,		/* SATA disk controller */
			UCLASS_AUDIO_CODEC,	/* Audio codec with control and data path */
			UCLASS_AXI,		/* AXI bus */
			UCLASS_BLK,		/* Block device */
			UCLASS_BOOTCOUNT,       /* Bootcount backing store */
			UCLASS_BUTTON,		/* Button */
			UCLASS_CACHE,		/* Cache controller */
			UCLASS_CLK,		/* Clock source, e.g. used by peripherals */
			UCLASS_CPU,		/* CPU, typically part of an SoC */
			UCLASS_CROS_EC,		/* Chrome OS EC */
			UCLASS_DISPLAY,		/* Display (e.g. DisplayPort, HDMI) */
			UCLASS_DSI_HOST,	/* Display Serial Interface host */
			UCLASS_DMA,		/* Direct Memory Access */
			UCLASS_DSA,		/* Distributed (Ethernet) Switch Architecture */
			UCLASS_ECDSA,		/* Elliptic curve cryptographic device */
			UCLASS_EFI,		/* EFI managed devices */
			UCLASS_ETH,		/* Ethernet device */
			UCLASS_ETH_PHY,		/* Ethernet PHY device */
			UCLASS_FIRMWARE,	/* Firmware */
			UCLASS_FS_FIRMWARE_LOADER,		/* Generic loader */
			UCLASS_GPIO,		/* Bank of general-purpose I/O pins */
			UCLASS_HWSPINLOCK,	/* Hardware semaphores */
			UCLASS_I2C,		/* I2C bus */
			UCLASS_I2C_EEPROM,	/* I2C EEPROM device */
			UCLASS_I2C_GENERIC,	/* Generic I2C device */
			UCLASS_I2C_MUX,		/* I2C multiplexer */
			UCLASS_I2S,		/* I2S bus */
			UCLASS_IDE,		/* IDE device */
			UCLASS_IRQ,		/* Interrupt controller */
			UCLASS_KEYBOARD,	/* Keyboard input device */
			UCLASS_LED,		/* Light-emitting diode (LED) */
			UCLASS_LPC,		/* x86 'low pin count' interface */
			UCLASS_MAILBOX,		/* Mailbox controller */
			UCLASS_MASS_STORAGE,	/* Mass storage device */
			UCLASS_MDIO,		/* MDIO bus */
			UCLASS_MDIO_MUX,	/* MDIO MUX/switch */
			UCLASS_MISC,		/* Miscellaneous device */
			UCLASS_MMC,		/* SD / MMC card or chip */
			UCLASS_MOD_EXP,		/* RSA Mod Exp device */
			UCLASS_MTD,		/* Memory Technology Device (MTD) device */
			UCLASS_MUX,		/* Multiplexer device */
			UCLASS_NOP,		/* No-op devices */
			UCLASS_NORTHBRIDGE,	/* Intel Northbridge / SDRAM controller */
			UCLASS_NVME,		/* NVM Express device */
			UCLASS_P2SB,		/* (x86) Primary-to-Sideband Bus */
			UCLASS_PANEL,		/* Display panel, such as an LCD */
			UCLASS_PANEL_BACKLIGHT,	/* Backlight controller for panel */
			UCLASS_PCH,		/* x86 platform controller hub */
			UCLASS_PCI,		/* PCI bus */
			UCLASS_PCI_EP,		/* PCI endpoint device */
			UCLASS_PCI_GENERIC,	/* Generic PCI bus device */
			UCLASS_PHY,		/* Physical Layer (PHY) device */
			UCLASS_PINCONFIG,	/* Pin configuration node device */
			UCLASS_PINCTRL,		/* Pinctrl (pin muxing/configuration) device */
			UCLASS_PMIC,		/* PMIC I/O device */
			UCLASS_POWER_DOMAIN,	/* (SoC) Power domains */
			UCLASS_PWM,		/* Pulse-width modulator */
			UCLASS_PWRSEQ,		/* Power sequence device */
			UCLASS_QFW,		/* QEMU firmware config device */
			UCLASS_RAM,		/* RAM controller */
			UCLASS_REBOOT_MODE,	/* Reboot mode */
			UCLASS_REGULATOR,	/* Regulator device */
			UCLASS_REMOTEPROC,	/* Remote Processor device */
			UCLASS_RESET,		/* Reset controller device */
			UCLASS_RNG,		/* Random Number Generator */
			UCLASS_RTC,		/* Real time clock device */
			UCLASS_SCMI_AGENT,	/* Interface with an SCMI server */
			UCLASS_SCSI,		/* SCSI device */
			UCLASS_SERIAL,		/* Serial UART */
			UCLASS_SIMPLE_BUS,	/* Bus with child devices */
			UCLASS_SMEM,		/* Shared memory interface */
			UCLASS_SOC,		/* SOC Device */
			UCLASS_SOUND,		/* Playing simple sounds */
			UCLASS_SPI,		/* SPI bus */
			UCLASS_SPI_FLASH,	/* SPI flash */
			UCLASS_SPI_GENERIC,	/* Generic SPI flash target */
			UCLASS_SPMI,		/* System Power Management Interface bus */
			UCLASS_SYSCON,		/* System configuration device */
			UCLASS_SYSINFO,		/* Device information from hardware */
			UCLASS_SYSRESET,	/* System reset device */
			UCLASS_TEE,		/* Trusted Execution Environment device */
			UCLASS_THERMAL,		/* Thermal sensor */
			UCLASS_TIMER,		/* Timer device */
			UCLASS_TPM,		/* Trusted Platform Module TIS interface */
			UCLASS_UFS,		/* Universal Flash Storage */
			UCLASS_USB,		/* USB bus */
			UCLASS_USB_DEV_GENERIC,	/* USB generic device */
			UCLASS_USB_HUB,		/* USB hub */
			UCLASS_USB_GADGET_GENERIC,	/* USB generic device */
			UCLASS_VIDEO,		/* Video or LCD device */
			UCLASS_VIDEO_BRIDGE,	/* Video bridge, e.g. DisplayPort to LVDS */
			UCLASS_VIDEO_CONSOLE,	/* Text console driver for video device */
			UCLASS_VIDEO_OSD,	/* On-screen display */
			UCLASS_VIRTIO,		/* VirtIO transport device */
			UCLASS_W1,		/* Dallas 1-Wire bus */
			UCLASS_W1_EEPROM,	/* one-wire EEPROMs */
			UCLASS_WDT,		/* Watchdog Timer driver */
			UCLASS_PVBLOCK,		/* Xen virtual block device */

			UCLASS_COUNT,
			UCLASS_INVALID = -1,
		};

# 关系
上层接口都是和uclass的接口直接通讯

uclass可以理解为一些具有相同属性的udevice对外操作的接口，uclass的驱动是uclass_driver，主要为上层提供接口;  
udevice的是指具体设备的抽象，对应驱动是driver，driver主要负责和硬件通信，为uclass提供实际的操作集;  

udevice找到对应的uclass的方式主要是通过：udevice对应的driver的id和uclass对应的uclass_driver的id是否匹配;  

udevice会和uclass绑定。driver会和udevice绑定。uclass_driver会和uclass绑定。  
关系图如下：  
![](https://github.com/iToday/imx6ull_linux/blob/main/doc/uboot/imgs/driver%20model.svg)

# 实例分析

下面分别以I2C、RAM、NET驱动分析DM模型

## I2C

### 驱动定义
介绍i2c驱动的声明定义；  
drivers/i2c-uclass.c中定义如下：

		UCLASS_DRIVER(i2c) = {
			.id		= UCLASS_I2C,
			.name		= "i2c",
			.flags		= DM_UC_FLAG_SEQ_ALIAS,
			.post_bind	= i2c_post_bind,
			.pre_probe      = i2c_pre_probe,
			.post_probe	= i2c_post_probe,
			.per_device_auto	= sizeof(struct dm_i2c_bus),
			.per_child_plat_auto	= sizeof(struct dm_i2c_chip),
			.child_post_bind = i2c_child_post_bind,
		};

		UCLASS_DRIVER(i2c_generic) = {
			.id		= UCLASS_I2C_GENERIC,
			.name		= "i2c_generic",
		};

		static const struct udevice_id generic_chip_i2c_ids[] = {
			{ .compatible = "i2c-chip", .data = I2C_DEVICE_GENERIC },
		#if CONFIG_IS_ENABLED(ACPIGEN)
			{ .compatible = "hid-over-i2c", .data = I2C_DEVICE_HID_OVER_I2C },
		#endif
			{ }
		};

		U_BOOT_DRIVER(i2c_generic_chip_drv) = {
			.name		= "i2c_generic_chip_drv",
			.id		= UCLASS_I2C_GENERIC,
			.of_match	= generic_chip_i2c_ids,
		#if CONFIG_IS_ENABLED(ACPIGEN)
			.of_to_plat	= acpi_i2c_of_to_plat,
			.priv_auto	= sizeof(struct acpi_i2c_priv),
		#endif
			ACPI_OPS_PTR(&acpi_i2c_ops)
		};
		
drivers/mxc_i2c.c

		static const struct dm_i2c_ops mxc_i2c_ops = {
			.xfer		= mxc_i2c_xfer,
			.probe_chip	= mxc_i2c_probe_chip,
			.set_bus_speed	= mxc_i2c_set_bus_speed,
		};

		static const struct udevice_id mxc_i2c_ids[] = {
			{ .compatible = "fsl,imx21-i2c", },
			{ .compatible = "fsl,vf610-i2c", .data = I2C_QUIRK_FLAG, },
			{}
		};

		U_BOOT_DRIVER(i2c_mxc) = {
			.name = "i2c_mxc",
			.id = UCLASS_I2C,
			.of_match = mxc_i2c_ids,
			.probe = mxc_i2c_probe,
			.priv_auto	= sizeof(struct mxc_i2c_bus),
			.ops = &mxc_i2c_ops,
			.flags = DM_FLAG_PRE_RELOC,
		};

展开后，定义了如下   
drivers/i2c-uclass.c

		struct uclass_driver _u_boot_list_2_uclass_2_i2c = {
			.id		= UCLASS_I2C,
			.name		= "i2c",
			.flags		= DM_UC_FLAG_SEQ_ALIAS,
			.post_bind	= i2c_post_bind,
			.pre_probe      = i2c_pre_probe,
			.post_probe	= i2c_post_probe,
			.per_device_auto	= sizeof(struct dm_i2c_bus),
			.per_child_plat_auto	= sizeof(struct dm_i2c_chip),
			.child_post_bind = i2c_child_post_bind,
		};

		struct uclass_driver u_boot_list_2_uclass_2_i2c_generic = {
			.id		= UCLASS_I2C_GENERIC,
			.name		= "i2c_generic",
		};

		static const struct udevice_id generic_chip_i2c_ids[] = {
			{ .compatible = "i2c-chip", .data = I2C_DEVICE_GENERIC },
		#if CONFIG_IS_ENABLED(ACPIGEN)
			{ .compatible = "hid-over-i2c", .data = I2C_DEVICE_HID_OVER_I2C },
		#endif
			{ }
		};

		struct driver _u_boot_list_2_driver_2_i2c_generic_chip_drv = {
			.name		= "i2c_generic_chip_drv",
			.id		= UCLASS_I2C_GENERIC,
			.of_match	= generic_chip_i2c_ids,
		#if CONFIG_IS_ENABLED(ACPIGEN)
			.of_to_plat	= acpi_i2c_of_to_plat,
			.priv_auto	= sizeof(struct acpi_i2c_priv),
		#endif
			ACPI_OPS_PTR(&acpi_i2c_ops)
		};

drivers/mxc_i2c.c

		static const struct dm_i2c_ops mxc_i2c_ops = {
			.xfer		= mxc_i2c_xfer,
			.probe_chip	= mxc_i2c_probe_chip,
			.set_bus_speed	= mxc_i2c_set_bus_speed,
		};

		static const struct udevice_id mxc_i2c_ids[] = {
			{ .compatible = "fsl,imx21-i2c", },
			{ .compatible = "fsl,vf610-i2c", .data = I2C_QUIRK_FLAG, },
			{}
		};

		struct driver _u_boot_list_2_driver_2_i2c_mxc = {
			.name = "i2c_mxc",
			.id = UCLASS_I2C,
			.of_match = mxc_i2c_ids,
			.probe = mxc_i2c_probe,
			.priv_auto	= sizeof(struct mxc_i2c_bus),
			.ops = &mxc_i2c_ops,
			.flags = DM_FLAG_PRE_RELOC,
		};

查看编译出来的u-boot.map中内容如下：
 grep -rn driver_2_i2c ./u-boot.map 
 
		10416:                0x0000000087849ef8                _u_boot_list_2_driver_2_i2c_generic_chip_drv
		10419:                0x0000000087849f3c                _u_boot_list_2_driver_2_i2c_mxc
		10545:                0x000000008784a3e4                _u_boot_list_2_uclass_driver_2_i2c
		10548:                0x000000008784a42c                _u_boot_list_2_uclass_driver_2_i2c_generic

### 驱动加载
介绍uboot启动过程中i2c驱动的加载、初始化流程；

### 驱动调用
介绍外设启动调用i2c驱动的流程；

## RAM

## NET
