<!-- TOC -->

- [简介](#%E7%AE%80%E4%BB%8B)
- [udevice](#udevice)
- [driver](#driver)
- [uclass](#uclass)
- [关系](#%E5%85%B3%E7%B3%BB)
- [实例分析](#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90)
    - [I2C](#i2c)
        - [驱动定义](#%E9%A9%B1%E5%8A%A8%E5%AE%9A%E4%B9%89)
        - [驱动加载](#%E9%A9%B1%E5%8A%A8%E5%8A%A0%E8%BD%BD)
            - [i2c cmd](#i2c-cmd)
            - [power on](#power-on)
        - [驱动调用](#%E9%A9%B1%E5%8A%A8%E8%B0%83%E7%94%A8)
    - [RAM](#ram)
    - [NET](#net)

<!-- /TOC -->

# 简介
DM 是 U-Boot 中的驱动框架，全称 Driver Mode。

DM 有自己的三要素：udevice、uclass、driver。

udevice 描述具体的某一个硬件设备。

driver 是与这个设备匹配的驱动。

uclass 是同一类设备的抽象，提供管理同一类设备的抽象接口。

# udevice 
描述具体的某一个硬件设备。

		/**
		 * struct udevice - An instance of a driver
		 *
		 * 包含有关设备的信息，该设备是绑定到特定端口或外围设备的驱动程序（本质上是一个驱动程序实例）。

		 * 设备将通过“bind”调用出现，要么是由一个 U_BOOT_DRVINFO() 宏（在这种情况下 plat 是非空的）或设备树中的一个节点（在这种情况下 of_offset >= 0）。 
		 * 在后一种情况下，我们在驱动程序 of_to_plat 方法（如果设备具有设备树节点，则在探测方法之前调用）实现的函数中将设备树信息转换为 plat。

		 * plat, priv 和 uclass_priv 这三个都可以由驱动程序分配，也可以使用struct driver 和struct uclass_driver 的auto 成员让驱动程序模型自动分配。
		 *
		 * @driver: 设备对应的驱动
		 * @name: 设备名称，通常为FDT中节点名称
		 * @plat_: 设备配置数据
		 * @parent_plat_: 设备父总线的配置数据
		 * @uclass_plat_: 设备对应uclass的配置数据
		 * @driver_data: Driver data word for the entry that matched this device with its driver
		 * @parent: Parent of this device, or NULL for the top level device
		 * @priv_: Private data for this device (do not access outside driver model)
		 * @uclass: Pointer to uclass for this device
		 * @uclass_priv_: The uclass's private data for this device (do not access outside driver model)
		 * @parent_priv_: The parent's private data for this device (do not access outside driver model)
		 * @uclass_node: Used by uclass to link its devices
		 * @child_head: List of children of this device
		 * @sibling_node: Next device in list of all devices
		 * @flags_: Flags for this device DM_FLAG_... (do not access outside driver model)
		 * @seq_: Allocated sequence number for this device (-1 = none). This is set up
		 * when the device is bound and is unique within the device's uclass. If the
		 * device has an alias in the devicetree then that is used to set the sequence
		 * number. Otherwise, the next available number is used. Sequence numbers are
		 * used by certain commands that need device to be numbered (e.g. 'mmc dev').
		 * (do not access outside driver model)
		 * @node_: Reference to device tree node for this device (do not access outside
		 *	driver model)
		 * @devres_head: List of memory allocations associated with this device.
		 *		When CONFIG_DEVRES is enabled, devm_kmalloc() and friends will
		 *		add to this list. Memory so-allocated will be freed
		 *		automatically when the device is removed / unbound
		 * @dma_offset: Offset between the physical address space (CPU's) and the
		 *		device's bus address space
		 */
		struct udevice {
			const struct driver *driver;
			const char *name;
			void *plat_;
			void *parent_plat_;
			void *uclass_plat_;
			ulong driver_data;
			struct udevice *parent;
			void *priv_;
			struct uclass *uclass;
			void *uclass_priv_;
			void *parent_priv_;
			struct list_head uclass_node;
			struct list_head child_head;
			struct list_head sibling_node;
		#if !CONFIG_IS_ENABLED(OF_PLATDATA_RT)
			u32 flags_;
		#endif
			int seq_;
		#if !CONFIG_IS_ENABLED(OF_PLATDATA)
			ofnode node_;
		#endif
		#ifdef CONFIG_DEVRES
			struct list_head devres_head;
		#endif
		#if CONFIG_IS_ENABLED(DM_DMA)
			ulong dma_offset;
		#endif
		};


# driver 
与设备匹配的驱动。

		/**
		 * struct driver - A driver for a feature or peripheral
		 *
		 *	包含安装设备和删除设备的方法。
			设备需要信息来设置自己 - 这要么提供通过 plat 或设备树节点（我们通过查找与 of_match 匹配的兼容字符串来找到）。

			  驱动程序都属于一个 uclass，代表一个类的设备
			  同类型。 驱动程序的公共元素可以在 uclass 中实现，或者 uclass 可以为其中的驱动程序提供一致的接口。

		 * This holds methods for setting up a new device, and also removing it.
		 * The device needs information to set itself up - this is provided either
		 * by plat or a device tree node (which we find by looking up
		 * matching compatible strings with of_match).
		 *
		 * Drivers all belong to a uclass, representing a class of devices of the
		 * same type. Common elements of the drivers can be implemented in the uclass,
		 * or the uclass can provide a consistent interface to the drivers within
		 * it.
		 *
		 * @name: Device name
		 * @id: Identifies the uclass we belong to
		 * @of_match: List of compatible strings to match, and any identifying data
		 * for each.
		 * @bind: Called to bind a device to its driver
		 * @probe: Called to probe a device, i.e. activate it
		 * @remove: Called to remove a device, i.e. de-activate it
		 * @unbind: Called to unbind a device from its driver
		 * @of_to_plat: Called before probe to decode device tree data
		 * @child_post_bind: Called after a new child has been bound
		 * @child_pre_probe: Called before a child device is probed. The device has
		 * memory allocated but it has not yet been probed.
		 * @child_post_remove: Called after a child device is removed. The device
		 * has memory allocated but its device_remove() method has been called.
		 * @priv_auto: If non-zero this is the size of the private data
		 * to be allocated in the device's ->priv pointer. If zero, then the driver
		 * is responsible for allocating any data required.
		 * @plat_auto: If non-zero this is the size of the
		 * platform data to be allocated in the device's ->plat pointer.
		 * This is typically only useful for device-tree-aware drivers (those with
		 * an of_match), since drivers which use plat will have the data
		 * provided in the U_BOOT_DRVINFO() instantiation.
		 * @per_child_auto: Each device can hold private data owned by
		 * its parent. If required this will be automatically allocated if this
		 * value is non-zero.
		 * @per_child_plat_auto: A bus likes to store information about
		 * its children. If non-zero this is the size of this data, to be allocated
		 * in the child's parent_plat pointer.
		 * @ops: Driver-specific operations. This is typically a list of function
		 * pointers defined by the driver, to implement driver functions required by
		 * the uclass.
		 * @flags: driver flags - see DM_FLAGS_...
		 * @acpi_ops: Advanced Configuration and Power Interface (ACPI) operations,
		 * allowing the device to add things to the ACPI tables passed to Linux
		 */
		struct driver {
			char *name;
			enum uclass_id id;
			const struct udevice_id *of_match;
			int (*bind)(struct udevice *dev);
			int (*probe)(struct udevice *dev);
			int (*remove)(struct udevice *dev);
			int (*unbind)(struct udevice *dev);
			int (*of_to_plat)(struct udevice *dev);
			int (*child_post_bind)(struct udevice *dev);
			int (*child_pre_probe)(struct udevice *dev);
			int (*child_post_remove)(struct udevice *dev);
			int priv_auto;
			int plat_auto;
			int per_child_auto;
			int per_child_plat_auto;
			const void *ops;	/* driver-specific operations */
			uint32_t flags;
		#if CONFIG_IS_ENABLED(ACPIGEN)
			struct acpi_ops *acpi_ops;
		#endif
		};

		/* Declare a new U-Boot driver */
		#define U_BOOT_DRIVER(__name)						\
			ll_entry_declare(struct driver, __name, driver)


# uclass 
同一类设备的抽象，提供管理同一类设备的抽象接口。

		/**
		 * struct uclass - 一个 U-Boot 驱动类，将相似的驱动抽象
		 *
		 * uclass 为特定功能提供接口，该功能由一个或多个驱动程序实现。 每个驱动程序都属于一个 uclass，
		 * 即使它是该 uclass 中的唯一驱动程序。 一个示例 uclass 是 GPIO，它提供更改读取输入、设置和清除输出等的能力。

		 * 可能有片上 SoC GPIO 组、I2C GPIO 扩展器和 PMIC IO 线的驱动程序，所有这些都通过 uclass 以统一方式提供。
		 *
		 * @priv_: Private data for this uclass (do not access outside driver model)
		 * @uc_drv: The driver for the uclass itself, not to be confused with a
		 * 'struct driver'
		 * @dev_head: List of devices in this uclass (devices are attached to their
		 * uclass when their bind method is called)
		 * @sibling_node: Next uclass in the linked list of uclasses
		 */
		struct uclass {
			void *priv_;
			struct uclass_driver *uc_drv;
			struct list_head dev_head;
			struct list_head sibling_node;
		};



		/**
		 * struct uclass_driver - Driver for the uclass
		 *
		 * uclass_driver 为一组相关的驱动程序提供了一致的接口，接口抽象
		 *
		 * @name: Name of uclass driver
		 * @id: ID number of this uclass

		 * 一个uclass_driver有下面可实现的接口：

		 * @post_bind: Called after a new device is bound to this uclass
		 * @pre_unbind: Called before a device is unbound from this uclass
		 * @pre_probe: Called before a new device is probed
		 * @post_probe: Called after a new device is probed
		 * @pre_remove: Called before a device is removed
		 * @child_post_bind: Called after a child is bound to a device in this uclass
		 * @child_pre_probe: Called before a child in this uclass is probed
		 * @child_post_probe: Called after a child in this uclass is probed
		 * @init: Called to set up the uclass
		 * @destroy: Called to destroy the uclass

		 * @priv_auto: If non-zero this is the size of the private data
		 * to be allocated in the uclass's ->priv pointer. If zero, then the uclass
		 * driver is responsible for allocating any data required.
		 * @per_device_auto: Each device can hold private data owned
		 * by the uclass. If required this will be automatically allocated if this
		 * value is non-zero.
		 * @per_device_plat_auto: Each device can hold platform data
		 * owned by the uclass as 'dev->uclass_plat'. If the value is non-zero,
		 * then this will be automatically allocated.
		 * @per_child_auto: Each child device (of a parent in this
		 * uclass) can hold parent data for the device/uclass. This value is only
		 * used as a fallback if this member is 0 in the driver.
		 * @per_child_plat_auto: A bus likes to store information about
		 * its children. If non-zero this is the size of this data, to be allocated
		 * in the child device's parent_plat pointer. This value is only used as
		 * a fallback if this member is 0 in the driver.
		 * @flags: Flags for this uclass (DM_UC_...)
		 */
		struct uclass_driver {
			const char *name;
			enum uclass_id id;
			int (*post_bind)(struct udevice *dev);
			int (*pre_unbind)(struct udevice *dev);
			int (*pre_probe)(struct udevice *dev);
			int (*post_probe)(struct udevice *dev);
			int (*pre_remove)(struct udevice *dev);
			int (*child_post_bind)(struct udevice *dev);
			int (*child_pre_probe)(struct udevice *dev);
			int (*child_post_probe)(struct udevice *dev);
			int (*init)(struct uclass *class);
			int (*destroy)(struct uclass *class);
			int priv_auto;
			int per_device_auto;
			int per_device_plat_auto;
			int per_child_auto;
			int per_child_plat_auto;
			uint32_t flags;
		};

		/* Declare a new uclass_driver */
		#define UCLASS_DRIVER(__name)						\
			ll_entry_declare(struct uclass_driver, __name, uclass_driver)

		enum uclass_id {
			/* These are used internally by driver model */
			UCLASS_ROOT = 0,
			UCLASS_DEMO,
			UCLASS_TEST,
			UCLASS_TEST_FDT,
			UCLASS_TEST_FDT_MANUAL,
			UCLASS_TEST_BUS,
			UCLASS_TEST_PROBE,
			UCLASS_TEST_DUMMY,
			UCLASS_TEST_DEVRES,
			UCLASS_TEST_ACPI,
			UCLASS_SPI_EMUL,	/* sandbox SPI device emulator */
			UCLASS_I2C_EMUL,	/* sandbox I2C device emulator */
			UCLASS_I2C_EMUL_PARENT,	/* parent for I2C device emulators */
			UCLASS_PCI_EMUL,	/* sandbox PCI device emulator */
			UCLASS_PCI_EMUL_PARENT,	/* parent for PCI device emulators */
			UCLASS_USB_EMUL,	/* sandbox USB bus device emulator */
			UCLASS_AXI_EMUL,	/* sandbox AXI bus device emulator */

			/* U-Boot uclasses start here - in alphabetical order */
			UCLASS_ACPI_PMC,	/* (x86) Power-management controller (PMC) */
			UCLASS_ADC,		/* Analog-to-digital converter */
			UCLASS_AHCI,		/* SATA disk controller */
			UCLASS_AUDIO_CODEC,	/* Audio codec with control and data path */
			UCLASS_AXI,		/* AXI bus */
			UCLASS_BLK,		/* Block device */
			UCLASS_BOOTCOUNT,       /* Bootcount backing store */
			UCLASS_BUTTON,		/* Button */
			UCLASS_CACHE,		/* Cache controller */
			UCLASS_CLK,		/* Clock source, e.g. used by peripherals */
			UCLASS_CPU,		/* CPU, typically part of an SoC */
			UCLASS_CROS_EC,		/* Chrome OS EC */
			UCLASS_DISPLAY,		/* Display (e.g. DisplayPort, HDMI) */
			UCLASS_DSI_HOST,	/* Display Serial Interface host */
			UCLASS_DMA,		/* Direct Memory Access */
			UCLASS_DSA,		/* Distributed (Ethernet) Switch Architecture */
			UCLASS_ECDSA,		/* Elliptic curve cryptographic device */
			UCLASS_EFI,		/* EFI managed devices */
			UCLASS_ETH,		/* Ethernet device */
			UCLASS_ETH_PHY,		/* Ethernet PHY device */
			UCLASS_FIRMWARE,	/* Firmware */
			UCLASS_FS_FIRMWARE_LOADER,		/* Generic loader */
			UCLASS_GPIO,		/* Bank of general-purpose I/O pins */
			UCLASS_HWSPINLOCK,	/* Hardware semaphores */
			UCLASS_I2C,		/* I2C bus */
			UCLASS_I2C_EEPROM,	/* I2C EEPROM device */
			UCLASS_I2C_GENERIC,	/* Generic I2C device */
			UCLASS_I2C_MUX,		/* I2C multiplexer */
			UCLASS_I2S,		/* I2S bus */
			UCLASS_IDE,		/* IDE device */
			UCLASS_IRQ,		/* Interrupt controller */
			UCLASS_KEYBOARD,	/* Keyboard input device */
			UCLASS_LED,		/* Light-emitting diode (LED) */
			UCLASS_LPC,		/* x86 'low pin count' interface */
			UCLASS_MAILBOX,		/* Mailbox controller */
			UCLASS_MASS_STORAGE,	/* Mass storage device */
			UCLASS_MDIO,		/* MDIO bus */
			UCLASS_MDIO_MUX,	/* MDIO MUX/switch */
			UCLASS_MISC,		/* Miscellaneous device */
			UCLASS_MMC,		/* SD / MMC card or chip */
			UCLASS_MOD_EXP,		/* RSA Mod Exp device */
			UCLASS_MTD,		/* Memory Technology Device (MTD) device */
			UCLASS_MUX,		/* Multiplexer device */
			UCLASS_NOP,		/* No-op devices */
			UCLASS_NORTHBRIDGE,	/* Intel Northbridge / SDRAM controller */
			UCLASS_NVME,		/* NVM Express device */
			UCLASS_P2SB,		/* (x86) Primary-to-Sideband Bus */
			UCLASS_PANEL,		/* Display panel, such as an LCD */
			UCLASS_PANEL_BACKLIGHT,	/* Backlight controller for panel */
			UCLASS_PCH,		/* x86 platform controller hub */
			UCLASS_PCI,		/* PCI bus */
			UCLASS_PCI_EP,		/* PCI endpoint device */
			UCLASS_PCI_GENERIC,	/* Generic PCI bus device */
			UCLASS_PHY,		/* Physical Layer (PHY) device */
			UCLASS_PINCONFIG,	/* Pin configuration node device */
			UCLASS_PINCTRL,		/* Pinctrl (pin muxing/configuration) device */
			UCLASS_PMIC,		/* PMIC I/O device */
			UCLASS_POWER_DOMAIN,	/* (SoC) Power domains */
			UCLASS_PWM,		/* Pulse-width modulator */
			UCLASS_PWRSEQ,		/* Power sequence device */
			UCLASS_QFW,		/* QEMU firmware config device */
			UCLASS_RAM,		/* RAM controller */
			UCLASS_REBOOT_MODE,	/* Reboot mode */
			UCLASS_REGULATOR,	/* Regulator device */
			UCLASS_REMOTEPROC,	/* Remote Processor device */
			UCLASS_RESET,		/* Reset controller device */
			UCLASS_RNG,		/* Random Number Generator */
			UCLASS_RTC,		/* Real time clock device */
			UCLASS_SCMI_AGENT,	/* Interface with an SCMI server */
			UCLASS_SCSI,		/* SCSI device */
			UCLASS_SERIAL,		/* Serial UART */
			UCLASS_SIMPLE_BUS,	/* Bus with child devices */
			UCLASS_SMEM,		/* Shared memory interface */
			UCLASS_SOC,		/* SOC Device */
			UCLASS_SOUND,		/* Playing simple sounds */
			UCLASS_SPI,		/* SPI bus */
			UCLASS_SPI_FLASH,	/* SPI flash */
			UCLASS_SPI_GENERIC,	/* Generic SPI flash target */
			UCLASS_SPMI,		/* System Power Management Interface bus */
			UCLASS_SYSCON,		/* System configuration device */
			UCLASS_SYSINFO,		/* Device information from hardware */
			UCLASS_SYSRESET,	/* System reset device */
			UCLASS_TEE,		/* Trusted Execution Environment device */
			UCLASS_THERMAL,		/* Thermal sensor */
			UCLASS_TIMER,		/* Timer device */
			UCLASS_TPM,		/* Trusted Platform Module TIS interface */
			UCLASS_UFS,		/* Universal Flash Storage */
			UCLASS_USB,		/* USB bus */
			UCLASS_USB_DEV_GENERIC,	/* USB generic device */
			UCLASS_USB_HUB,		/* USB hub */
			UCLASS_USB_GADGET_GENERIC,	/* USB generic device */
			UCLASS_VIDEO,		/* Video or LCD device */
			UCLASS_VIDEO_BRIDGE,	/* Video bridge, e.g. DisplayPort to LVDS */
			UCLASS_VIDEO_CONSOLE,	/* Text console driver for video device */
			UCLASS_VIDEO_OSD,	/* On-screen display */
			UCLASS_VIRTIO,		/* VirtIO transport device */
			UCLASS_W1,		/* Dallas 1-Wire bus */
			UCLASS_W1_EEPROM,	/* one-wire EEPROMs */
			UCLASS_WDT,		/* Watchdog Timer driver */
			UCLASS_PVBLOCK,		/* Xen virtual block device */

			UCLASS_COUNT,
			UCLASS_INVALID = -1,
		};

# 关系
上层接口都是和uclass的接口直接通讯

uclass可以理解为一些具有相同属性的udevice对外操作的接口，uclass的驱动是uclass_driver，主要为上层提供接口;  
udevice的是指具体设备的抽象，对应驱动是driver，driver主要负责和硬件通信，为uclass提供实际的操作集;  

udevice找到对应的uclass的方式主要是通过：udevice对应的driver的id和uclass对应的uclass_driver的id是否匹配;  

udevice会和uclass绑定。driver会和udevice绑定。uclass_driver会和uclass绑定。  
关系图如下：  
![](https://github.com/iToday/imx6ull_linux/blob/main/doc/uboot/imgs/driver%20model.svg)

# 实例分析

下面分别以I2C、RAM、NET驱动分析DM模型

## I2C

### 驱动定义
介绍i2c驱动的声明定义；  
drivers/i2c-uclass.c中定义如下：

		UCLASS_DRIVER(i2c) = {
			.id		= UCLASS_I2C,
			.name		= "i2c",
			.flags		= DM_UC_FLAG_SEQ_ALIAS,
			.post_bind	= i2c_post_bind,
			.pre_probe      = i2c_pre_probe,
			.post_probe	= i2c_post_probe,
			.per_device_auto	= sizeof(struct dm_i2c_bus),
			.per_child_plat_auto	= sizeof(struct dm_i2c_chip),
			.child_post_bind = i2c_child_post_bind,
		};

		UCLASS_DRIVER(i2c_generic) = {
			.id		= UCLASS_I2C_GENERIC,
			.name		= "i2c_generic",
		};

		static const struct udevice_id generic_chip_i2c_ids[] = {
			{ .compatible = "i2c-chip", .data = I2C_DEVICE_GENERIC },
		#if CONFIG_IS_ENABLED(ACPIGEN)
			{ .compatible = "hid-over-i2c", .data = I2C_DEVICE_HID_OVER_I2C },
		#endif
			{ }
		};

		U_BOOT_DRIVER(i2c_generic_chip_drv) = {
			.name		= "i2c_generic_chip_drv",
			.id		= UCLASS_I2C_GENERIC,
			.of_match	= generic_chip_i2c_ids,
		#if CONFIG_IS_ENABLED(ACPIGEN)
			.of_to_plat	= acpi_i2c_of_to_plat,
			.priv_auto	= sizeof(struct acpi_i2c_priv),
		#endif
			ACPI_OPS_PTR(&acpi_i2c_ops)
		};
		
drivers/mxc_i2c.c

		static const struct dm_i2c_ops mxc_i2c_ops = {
			.xfer		= mxc_i2c_xfer,
			.probe_chip	= mxc_i2c_probe_chip,
			.set_bus_speed	= mxc_i2c_set_bus_speed,
		};

		static const struct udevice_id mxc_i2c_ids[] = {
			{ .compatible = "fsl,imx21-i2c", },
			{ .compatible = "fsl,vf610-i2c", .data = I2C_QUIRK_FLAG, },
			{}
		};

		U_BOOT_DRIVER(i2c_mxc) = {
			.name = "i2c_mxc",
			.id = UCLASS_I2C,
			.of_match = mxc_i2c_ids,
			.probe = mxc_i2c_probe,
			.priv_auto	= sizeof(struct mxc_i2c_bus),
			.ops = &mxc_i2c_ops,
			.flags = DM_FLAG_PRE_RELOC,
		};

展开后，定义了如下   
drivers/i2c-uclass.c

		struct uclass_driver _u_boot_list_2_uclass_2_i2c = {
			.id		= UCLASS_I2C,
			.name		= "i2c",
			.flags		= DM_UC_FLAG_SEQ_ALIAS,
			.post_bind	= i2c_post_bind,
			.pre_probe      = i2c_pre_probe,
			.post_probe	= i2c_post_probe,
			.per_device_auto	= sizeof(struct dm_i2c_bus),
			.per_child_plat_auto	= sizeof(struct dm_i2c_chip),
			.child_post_bind = i2c_child_post_bind,
		};

		struct uclass_driver u_boot_list_2_uclass_2_i2c_generic = {
			.id		= UCLASS_I2C_GENERIC,
			.name		= "i2c_generic",
		};

		static const struct udevice_id generic_chip_i2c_ids[] = {
			{ .compatible = "i2c-chip", .data = I2C_DEVICE_GENERIC },
		#if CONFIG_IS_ENABLED(ACPIGEN)
			{ .compatible = "hid-over-i2c", .data = I2C_DEVICE_HID_OVER_I2C },
		#endif
			{ }
		};

		struct driver _u_boot_list_2_driver_2_i2c_generic_chip_drv = {
			.name		= "i2c_generic_chip_drv",
			.id		= UCLASS_I2C_GENERIC,
			.of_match	= generic_chip_i2c_ids,
		#if CONFIG_IS_ENABLED(ACPIGEN)
			.of_to_plat	= acpi_i2c_of_to_plat,
			.priv_auto	= sizeof(struct acpi_i2c_priv),
		#endif
			ACPI_OPS_PTR(&acpi_i2c_ops)
		};

drivers/mxc_i2c.c

		static const struct dm_i2c_ops mxc_i2c_ops = {
			.xfer		= mxc_i2c_xfer,
			.probe_chip	= mxc_i2c_probe_chip,
			.set_bus_speed	= mxc_i2c_set_bus_speed,
		};

		static const struct udevice_id mxc_i2c_ids[] = {
			{ .compatible = "fsl,imx21-i2c", },
			{ .compatible = "fsl,vf610-i2c", .data = I2C_QUIRK_FLAG, },
			{}
		};

		struct driver _u_boot_list_2_driver_2_i2c_mxc = {
			.name = "i2c_mxc",
			.id = UCLASS_I2C,
			.of_match = mxc_i2c_ids,
			.probe = mxc_i2c_probe,
			.priv_auto	= sizeof(struct mxc_i2c_bus),
			.ops = &mxc_i2c_ops,
			.flags = DM_FLAG_PRE_RELOC,
		};

查看编译出来的u-boot.map中内容如下：
 grep -rn driver_2_i2c ./u-boot.map 
 
		10416:                0x0000000087849ef8                _u_boot_list_2_driver_2_i2c_generic_chip_drv
		10419:                0x0000000087849f3c                _u_boot_list_2_driver_2_i2c_mxc
		10545:                0x000000008784a3e4                _u_boot_list_2_uclass_driver_2_i2c
		10548:                0x000000008784a42c                _u_boot_list_2_uclass_driver_2_i2c_generic

### 驱动加载
介绍uboot启动过程中i2c驱动的加载、初始化流程；

#### i2c cmd
drivers/i2c/i2c-uclass.c

		int dm_i2c_probe(struct udevice *bus, uint chip_addr, uint chip_flags,
				struct udevice **devp)
		{
			int ret;

			*devp = NULL;

			/* First probe that chip */
			ret = i2c_probe_chip(bus, chip_addr, chip_flags);
			debug("%s: bus='%s', address %02x, ret=%d\n", __func__, bus->name,
				chip_addr, ret);
			if (ret)
				return ret;

			/* The chip was found, see if we have a driver, and probe it */
			ret = i2c_get_chip(bus, chip_addr, 1, devp);
			debug("%s:  i2c_get_chip: ret=%d\n", __func__, ret);

			return ret;
		}

		static int i2c_probe_chip(struct udevice *bus, uint chip_addr,
			  enum dm_i2c_chip_flags chip_flags)
		{
			struct dm_i2c_ops *ops = i2c_get_ops(bus);
			struct i2c_msg msg[1];
			int ret;

			if (ops->probe_chip) {
				ret = ops->probe_chip(bus, chip_addr, chip_flags);
				if (!ret || ret != -ENOSYS)
					return ret;
			}

			if (!ops->xfer)
				return -ENOSYS;

			/* Probe with a zero-length message */
			msg->addr = chip_addr;
			msg->flags = chip_flags & DM_I2C_CHIP_10BIT ? I2C_M_TEN : 0;
			msg->len = 0;
			msg->buf = NULL;

			return ops->xfer(bus, msg, 1);
		}

drivers/i2c/mxc_i2c.c

		/* Sends: S Addr Wr [A|NA] P */
		static int mxc_i2c_probe_chip(struct udevice *bus, u32 chip_addr,
						u32 chip_flags)
		{
			int ret;
			struct mxc_i2c_bus *i2c_bus = dev_get_priv(bus);

			ret = i2c_init_transfer(i2c_bus, chip_addr, 0, 0);
			if (ret < 0) {
				debug("%s failed, ret = %d\n", __func__, ret);
				return ret;
			}

			i2c_imx_stop(i2c_bus);

			return 0;
		}

dirvers/i2c/i2c-uclass.c
		int i2c_get_chip(struct udevice *bus, uint chip_addr, uint offset_len,
				struct udevice **devp)
		{
			struct udevice *dev;

			debug("%s: Searching bus '%s' for address %02x: ", __func__,
				bus->name, chip_addr);
			for (device_find_first_child(bus, &dev); dev;
					device_find_next_child(&dev)) {
				struct dm_i2c_chip *chip = dev_get_parent_plat(dev);
				int ret;

				if (chip->chip_addr == (chip_addr &
							~chip->chip_addr_offset_mask)) {
					ret = device_probe(dev);
					debug("found, ret=%d\n", ret);
					if (ret)
						return ret;
					*devp = dev;
					return 0;
				}
			}
			debug("not found\n");
			return i2c_bind_driver(bus, chip_addr, offset_len, devp);
		}


		static int i2c_bind_driver(struct udevice *bus, uint chip_addr, uint offset_len,
					struct udevice **devp)
		{
			struct dm_i2c_chip *chip;
			char name[30], *str;
			struct udevice *dev;
			int ret;

			snprintf(name, sizeof(name), "generic_%x", chip_addr);
			str = strdup(name);
			if (!str)
				return -ENOMEM;
			ret = device_bind_driver(bus, "i2c_generic_chip_drv", str, &dev);
			debug("%s:  device_bind_driver: ret=%d\n", __func__, ret);
			if (ret)
				goto err_bind;

			/* Tell the device what we know about it */
			chip = dev_get_parent_plat(dev);
			chip->chip_addr = chip_addr;
			chip->offset_len = offset_len;
			ret = device_probe(dev);
			debug("%s:  device_probe: ret=%d\n", __func__, ret);
			if (ret)
				goto err_probe;

			*devp = dev;
			return 0;

		err_probe:
			/*
			* If the device failed to probe, unbind it. There is nothing there
			* on the bus so we don't want to leave it lying around
			*/
			device_unbind(dev);
		err_bind:
			free(str);
			return ret;
		}
drivers/core/lists.c

		int device_bind_driver(struct udevice *parent, const char *drv_name,
					const char *dev_name, struct udevice **devp)
		{
			return device_bind_driver_to_node(parent, drv_name, dev_name,
							ofnode_null(), devp);
		}

		int device_bind_driver_to_node(struct udevice *parent, const char *drv_name,
						const char *dev_name, ofnode node,
						struct udevice **devp)
		{
			struct driver *drv;
			int ret;

			drv = lists_driver_lookup_name(drv_name);
			if (!drv) {
				debug("Cannot find driver '%s'\n", drv_name);
				return -ENOENT;
			}
			ret = device_bind_with_driver_data(parent, drv, dev_name, 0 /* data */,
							node, devp);

			return ret;
		}

drivers/core/device.c

		int device_bind_with_driver_data(struct udevice *parent,
				 const struct driver *drv, const char *name,
				 ulong driver_data, ofnode node,
				 struct udevice **devp)
		{
			return device_bind_common(parent, drv, name, NULL, driver_data, node,
						0, devp);
		}

		static int device_bind_common(struct udevice *parent, const struct driver *drv,
			      const char *name, void *plat,
			      ulong driver_data, ofnode node,
			      uint of_plat_size, struct udevice **devp)
		{
			struct udevice *dev;
			struct uclass *uc;
			int size, ret = 0;
			bool auto_seq = true;
			void *ptr;

			if (CONFIG_IS_ENABLED(OF_PLATDATA_NO_BIND))
				return -ENOSYS;

			if (devp)
				*devp = NULL;
			if (!name)
				return -EINVAL;

			ret = uclass_get(drv->id, &uc);
			if (ret) {
				debug("Missing uclass for driver %s\n", drv->name);
				return ret;
			}

			dev = calloc(1, sizeof(struct udevice));
			if (!dev)
				return -ENOMEM;

			INIT_LIST_HEAD(&dev->sibling_node);
			INIT_LIST_HEAD(&dev->child_head);
			INIT_LIST_HEAD(&dev->uclass_node);
		#ifdef CONFIG_DEVRES
			INIT_LIST_HEAD(&dev->devres_head);
		#endif
			dev_set_plat(dev, plat);
			dev->driver_data = driver_data;
			dev->name = name;
			dev_set_ofnode(dev, node);
			dev->parent = parent;
			dev->driver = drv;
			dev->uclass = uc;

			dev->seq_ = -1;
			if (CONFIG_IS_ENABLED(DM_SEQ_ALIAS) &&
				(uc->uc_drv->flags & DM_UC_FLAG_SEQ_ALIAS)) {
				/*
				* Some devices, such as a SPI bus, I2C bus and serial ports
				* are numbered using aliases.
				*/
				if (CONFIG_IS_ENABLED(OF_CONTROL) &&
					!CONFIG_IS_ENABLED(OF_PLATDATA)) {
					if (uc->uc_drv->name && ofnode_valid(node)) {
						if (!dev_read_alias_seq(dev, &dev->seq_)) {
							auto_seq = false;
							log_debug("   - seq=%d\n", dev->seq_);
							}
					}
				}
			}
			if (auto_seq && !(uc->uc_drv->flags & DM_UC_FLAG_NO_AUTO_SEQ))
				dev->seq_ = uclass_find_next_free_seq(uc);

			/* Check if we need to allocate plat */
			if (drv->plat_auto) {
				bool alloc = !plat;

				/*
				* For of-platdata, we try use the existing data, but if
				* plat_auto is larger, we must allocate a new space
				*/
				if (CONFIG_IS_ENABLED(OF_PLATDATA)) {
					if (of_plat_size)
						dev_or_flags(dev, DM_FLAG_OF_PLATDATA);
					if (of_plat_size < drv->plat_auto)
						alloc = true;
				}
				if (alloc) {
					dev_or_flags(dev, DM_FLAG_ALLOC_PDATA);
					ptr = calloc(1, drv->plat_auto);
					if (!ptr) {
						ret = -ENOMEM;
						goto fail_alloc1;
					}

					/*
					* For of-platdata, copy the old plat into the new
					* space
					*/
					if (CONFIG_IS_ENABLED(OF_PLATDATA) && plat)
						memcpy(ptr, plat, of_plat_size);
					dev_set_plat(dev, ptr);
				}
			}

			size = uc->uc_drv->per_device_plat_auto;
			if (size) {
				dev_or_flags(dev, DM_FLAG_ALLOC_UCLASS_PDATA);
				ptr = calloc(1, size);
				if (!ptr) {
					ret = -ENOMEM;
					goto fail_alloc2;
				}
				dev_set_uclass_plat(dev, ptr);
			}

			if (parent) {
				size = parent->driver->per_child_plat_auto;
				if (!size)
					size = parent->uclass->uc_drv->per_child_plat_auto;
				if (size) {
					dev_or_flags(dev, DM_FLAG_ALLOC_PARENT_PDATA);
					ptr = calloc(1, size);
					if (!ptr) {
						ret = -ENOMEM;
						goto fail_alloc3;
					}
					dev_set_parent_plat(dev, ptr);
				}
				/* put dev into parent's successor list */
				list_add_tail(&dev->sibling_node, &parent->child_head);
			}

			ret = uclass_bind_device(dev);
			if (ret)
				goto fail_uclass_bind;

			/* if we fail to bind we remove device from successors and free it */
			if (drv->bind) {
				ret = drv->bind(dev);
				if (ret)
					goto fail_bind;
			}
			if (parent && parent->driver->child_post_bind) {
				ret = parent->driver->child_post_bind(dev);
				if (ret)
					goto fail_child_post_bind;
			}
			if (uc->uc_drv->post_bind) {
				ret = uc->uc_drv->post_bind(dev);
				if (ret)
					goto fail_uclass_post_bind;
			}

			if (parent)
				pr_debug("Bound device %s to %s\n", dev->name, parent->name);
			if (devp)
				*devp = dev;

			dev_or_flags(dev, DM_FLAG_BOUND);

			return 0;

		fail_uclass_post_bind:
			/* There is no child unbind() method, so no clean-up required */
		fail_child_post_bind:
			if (CONFIG_IS_ENABLED(DM_DEVICE_REMOVE)) {
				if (drv->unbind && drv->unbind(dev)) {
					dm_warn("unbind() method failed on dev '%s' on error path\n",
						dev->name);
				}
			}

		fail_bind:
			if (CONFIG_IS_ENABLED(DM_DEVICE_REMOVE)) {
				if (uclass_unbind_device(dev)) {
					dm_warn("Failed to unbind dev '%s' on error path\n",
						dev->name);
				}
			}
		fail_uclass_bind:
			if (CONFIG_IS_ENABLED(DM_DEVICE_REMOVE)) {
				list_del(&dev->sibling_node);
				if (dev_get_flags(dev) & DM_FLAG_ALLOC_PARENT_PDATA) {
					free(dev_get_parent_plat(dev));
					dev_set_parent_plat(dev, NULL);
				}
			}
		fail_alloc3:
			if (CONFIG_IS_ENABLED(DM_DEVICE_REMOVE)) {
				if (dev_get_flags(dev) & DM_FLAG_ALLOC_UCLASS_PDATA) {
					free(dev_get_uclass_plat(dev));
					dev_set_uclass_plat(dev, NULL);
				}
			}
		fail_alloc2:
			if (CONFIG_IS_ENABLED(DM_DEVICE_REMOVE)) {
				if (dev_get_flags(dev) & DM_FLAG_ALLOC_PDATA) {
					free(dev_get_plat(dev));
					dev_set_plat(dev, NULL);
				}
			}
		fail_alloc1:
			devres_release_all(dev);

			free(dev);

			return ret;
		}

drivers/core/uclass.c

		int uclass_bind_device(struct udevice *dev)
		{
			struct uclass *uc;
			int ret;

			uc = dev->uclass;
			list_add_tail(&dev->uclass_node, &uc->dev_head);

			if (dev->parent) {
				struct uclass_driver *uc_drv = dev->parent->uclass->uc_drv;

				if (uc_drv->child_post_bind) {
					ret = uc_drv->child_post_bind(dev);
					if (ret)
						goto err;
				}
			}

			return 0;
		err:
			/* There is no need to undo the parent's post_bind call */
			list_del(&dev->uclass_node);

			return ret;
		}

dirvers/i2c/i2c-uclass.c

		static int i2c_child_post_bind(struct udevice *dev)
		{
		#if CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)
			struct dm_i2c_chip *plat = dev_get_parent_plat(dev);

			if (!dev_has_ofnode(dev))
				return 0;
			return i2c_chip_of_to_plat(dev, plat);
		#else
			return 0;
		#endif
		}

完整流程如下：  

![](https://github.com/iToday/imx6ull_linux/blob/main/doc/uboot/imgs/i2c%20dm%20init.svg)

#### power on
设备上电时初始化入口如下：  
dirvers/core/root.c
		int dm_init_and_scan(bool pre_reloc_only)
		{
			int ret;

			ret = dm_init(CONFIG_IS_ENABLED(OF_LIVE));
			if (ret) {
				debug("dm_init() failed: %d\n", ret);
				return ret;
			}
			if (!CONFIG_IS_ENABLED(OF_PLATDATA_INST)) {
				ret = dm_scan(pre_reloc_only);
				if (ret) {
					log_debug("dm_scan() failed: %d\n", ret);
					return ret;
				}
			}

			return 0;
		}
完整流程如下：  
![](https://github.com/iToday/imx6ull_linux/blob/main/doc/uboot/imgs/i2c%20dm%20init2.svg)

### 驱动调用
介绍外设启动调用i2c驱动的流程；

参考cmd/i2c.c中命令的处理方式；

## RAM

## NET
