# u-boot启动流程分析
从上电开机执行u-boot,到u-boot加载操作系统的过程。
## 第一阶段
### 功能  
  .硬件设备初始化  
  .加载u-boot第二阶段代码到RAM空间  
  .设置好栈  
  .跳转到第二阶段代码入口  
### 启动流程
1.设置异常向量   
2.CPU进入SVC模式  
3.设置控制寄存器地址  
4.关闭看门狗  
5.屏蔽中断  
6.设置MPLLCON/UPLLCON/CLKDIVN  
7.关闭MMU和cache  
8.初始化存储控制器  
9.复制u-boot第二阶段代码到RAM  
10.设置栈  
11.清除BSS段  
12.跳转第二阶段入口

详细调用流程参考：  
**./arch/arm/cpu/armv7/start.S**

		/*************************************************************************
		 *
		 * Startup Code (reset vector)
		 *
		 * Do important init only if we don't start from memory!
		 * Setup memory and board specific bits prior to relocation.
		 * Relocate armboot to ram. Setup stack.
		 *
		 *************************************************************************/

			.globl	reset
			.globl	save_boot_params_ret
			.type   save_boot_params_ret,%function
		#ifdef CONFIG_ARMV7_LPAE
			.global	switch_to_hypervisor_ret
		#endif

		reset:
			/* Allow the board to save important registers */
			b	save_boot_params
		save_boot_params_ret:
		#ifdef CONFIG_ARMV7_LPAE
		/*
		 * check for Hypervisor support
		 */
			mrc	p15, 0, r0, c0, c1, 1		@ read ID_PFR1
			and	r0, r0, #CPUID_ARM_VIRT_MASK	@ mask virtualization bits
			cmp	r0, #(1 << CPUID_ARM_VIRT_SHIFT)
			beq	switch_to_hypervisor
		switch_to_hypervisor_ret:
		#endif
			/*
			 * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,
			 * except if in HYP mode already
			 */
			mrs	r0, cpsr
			and	r1, r0, #0x1f		@ mask mode bits
			teq	r1, #0x1a		@ test for HYP mode
			bicne	r0, r0, #0x1f		@ clear all mode bits
			orrne	r0, r0, #0x13		@ set SVC mode
			orr	r0, r0, #0xc0		@ disable FIQ and IRQ
			msr	cpsr,r0

		/*
		 * Setup vector:
		 * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
		 * Continue to use ROM code vector only in OMAP4 spl)
		 */
		#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))
			/* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */
			mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTLR Register
			bic	r0, #CR_V		@ V = 0
			mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTLR Register

		#ifdef CONFIG_HAS_VBAR
			/* Set vector address in CP15 VBAR register */
			ldr	r0, =_start
			mcr	p15, 0, r0, c12, c0, 0	@Set VBAR
		#endif
		#endif

			/* the mask ROM code should have PLL and others stable */
		#ifndef CONFIG_SKIP_LOWLEVEL_INIT
		#ifdef CONFIG_CPU_V7A
			bl	cpu_init_cp15
		#endif
		#ifndef CONFIG_SKIP_LOWLEVEL_INIT_ONLY
			bl	cpu_init_crit
		#endif
		#endif

			bl	_main

**./arch/arm/lib/crt0.S**

		ENTRY(_main)

		/*
		 * Set up initial C runtime environment and call board_init_f(0).
		 */

		#if defined(CONFIG_TPL_BUILD) && defined(CONFIG_TPL_NEEDS_SEPARATE_STACK)
			ldr	r0, =(CONFIG_TPL_STACK)
		#elif defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_STACK)
			ldr	r0, =(CONFIG_SPL_STACK)
		#else
			ldr	r0, =(CONFIG_SYS_INIT_SP_ADDR)
		#endif
			bic	r0, r0, #7	/* 8-byte alignment for ABI compliance */
			mov	sp, r0
			bl	board_init_f_alloc_reserve
			mov	sp, r0
			/* set up gd here, outside any C code */
			mov	r9, r0
			bl	board_init_f_init_reserve

		#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_EARLY_BSS)
			CLEAR_BSS
		#endif

			mov	r0, #0
			bl	board_init_f

		#if ! defined(CONFIG_SPL_BUILD)

		/*
		 * Set up intermediate environment (new sp and gd) and call
		 * relocate_code(addr_moni). Trick here is that we'll return
		 * 'here' but relocated.
		 */

			ldr	r0, [r9, #GD_START_ADDR_SP]	/* sp = gd->start_addr_sp */
			bic	r0, r0, #7	/* 8-byte alignment for ABI compliance */
			mov	sp, r0
			ldr	r9, [r9, #GD_NEW_GD]		/* r9 <- gd->new_gd */

			adr	lr, here
			ldr	r0, [r9, #GD_RELOC_OFF]		/* r0 = gd->reloc_off */
			add	lr, lr, r0
		#if defined(CONFIG_CPU_V7M)
			orr	lr, #1				/* As required by Thumb-only */
		#endif
			ldr	r0, [r9, #GD_RELOCADDR]		/* r0 = gd->relocaddr */
			b	relocate_code
		here:
		/*
		 * now relocate vectors
		 */

			bl	relocate_vectors

		/* Set up final (full) environment */

			bl	c_runtime_cpu_setup	/* we still call old routine here */
		#endif
		#if !defined(CONFIG_SPL_BUILD) || CONFIG_IS_ENABLED(FRAMEWORK)

		#if !defined(CONFIG_SPL_BUILD) || !defined(CONFIG_SPL_EARLY_BSS)
			CLEAR_BSS
		#endif

		# ifdef CONFIG_SPL_BUILD
			/* Use a DRAM stack for the rest of SPL, if requested */
			bl	spl_relocate_stack_gd
			cmp	r0, #0
			movne	sp, r0
			movne	r9, r0
		# endif

		#if ! defined(CONFIG_SPL_BUILD)
			bl coloured_LED_init
			bl red_led_on
		#endif
			/* call board_init_r(gd_t *id, ulong dest_addr) */
			mov     r0, r9                  /* gd_t */
			ldr	r1, [r9, #GD_RELOCADDR]	/* dest_addr */
			/* call board_init_r */
		#if CONFIG_IS_ENABLED(SYS_THUMB_BUILD)
			ldr	lr, =board_init_r	/* this is auto-relocated! */
			bx	lr
		#else
			ldr	pc, =board_init_r	/* this is auto-relocated! */
		#endif
			/* we should not return here. */
		#endif

		ENDPROC(_main)

对比以上_main 执行顺序为：
 
  1. 设置调用board_init_f()的初始环境。
  本环境只提供一个栈和一个存放的地方GD（'全局数据'）结构，两者都位于一些容易可用 RAM（SRAM、锁定缓存...）。在这种情况下，变量
  全局数据，无论是否初始化（BSS），都不可用；只要CONSTANT 初始化数据可用。 GD 应归零在 board_init_f() 被调用之前。
 
  2. 调用 board_init_f()。该函数为硬件准备从系统 RAM（DRAM、DDR...）执行，因为系统 RAM 可能不会  可用，board_init_f() 必须使用当前的 GD 才能存储任何必须传递到后期阶段的数据。这些数据包括重定位目的地、未来堆栈和未来的GD位置。
 
  3. 搭建以stack和GD为核心的中间环境由 board_init_f() 在系统 RAM 中分配的，但 BSS 和初始化的非常量数据仍然不可用。
 
  4. a.对于 U-Boot 正确（非 SPL），调用 relocate_code()。这个功能将 U-Boot 从当前位置重定位到重定位目标由 board_init_f() 计算。
 
  	 b.对于 SPL，board_init_f() 仅返回（到 crt0）。没有SPL 中的代码重定位。
 
  5. 设置调用board_init_r()的最终环境。这个环境有BSS（初始化为0），初始化非常量数据（初始化为其预期值），并在系统中堆栈 RAM（对于将堆栈和 GD 移动到 RAM 中的 SPL 是可选的 。 GD 保留了由 board_init_f() 设置的值。
 
  6. 对于 U-Boot 正确（不是 SPL），一些 CPU 有一些工作要做此时关于内存，因此调用 c_runtime_cpu_setup。
 
  7. 跳转到 board_init_r()。  

common/board_r.c中代码跳转如下：  
		void board_init_f(ulong dummy)
		{
			ccgr_init();

			/* setup AIPS and disable watchdog */
			arch_cpu_init();

			/* iomux and setup of i2c */
			board_early_init_f();

			/* setup GP timer */
			timer_init();

			/* UART clocks enabled and gd valid - init serial console */
			preloader_console_init();

			/* DDR initialization */
			spl_dram_init();

			/* Clear the BSS. */
			memset(__bss_start, 0, __bss_end - __bss_start);

			/* load/boot image from boot device */
			board_init_r(NULL, 0);
		}

## 第二阶段  
### 功能
  .初始化本阶段使用的硬件设备  
  .检测系统内存映射  
  .将内核从Flash读取到RAM中  
  .为内核设置启动参数  
  .调用内核
### 运行流程
1.板级相关初始化（board_init）  
2.时钟初始化（time_init）  
3.环境变量初始化（env_init）  
4.串口、控制台初始化（init_bandrare、serial_init、console_init_f）  
5.打印u-boot版本、编译时间等信息（display_banner)  
6.显示可用内存、显示内存大小（dram_init、display_dram_config）  
7.Nor flash初始化(flash_init)  
8.Nand Flash初始化(nand_init)  
9.调用main_loop(main_loop)

具体可见代码common/board_r.c中init_sequence_r定义：  

		static init_fnc_t init_sequence_r[] = {
			initr_trace,
			initr_reloc,
			/* TODO: could x86/PPC have this also perhaps? */
		#if defined(CONFIG_ARM) || defined(CONFIG_RISCV)
			initr_caches,
			/* Note: For Freescale LS2 SoCs, new MMU table is created in DDR.
			 *	 A temporary mapping of IFC high region is since removed,
			 *	 so environmental variables in NOR flash is not available
			 *	 until board_init() is called below to remap IFC to high
			 *	 region.
			 */
		#endif
			initr_reloc_global_data,
		#if defined(CONFIG_SYS_INIT_RAM_LOCK) && defined(CONFIG_E500)
			initr_unlock_ram_in_cache,
		#endif
			initr_barrier,
			initr_malloc,
			log_init,
			initr_bootstage,	/* Needs malloc() but has its own timer */
		#if defined(CONFIG_CONSOLE_RECORD)
			console_record_init,
		#endif
		#ifdef CONFIG_SYS_NONCACHED_MEMORY
			noncached_init,
		#endif
			initr_of_live,
		#ifdef CONFIG_DM
			initr_dm,
		#endif
		#ifdef CONFIG_ADDR_MAP
			initr_addr_map,
		#endif
		#if defined(CONFIG_ARM) || defined(CONFIG_NDS32) || defined(CONFIG_RISCV) || \
			defined(CONFIG_SANDBOX)
			board_init,	/* Setup chipselects */
		#endif
			/*
			 * TODO: printing of the clock inforamtion of the board is now
			 * implemented as part of bdinfo command. Currently only support for
			 * davinci SOC's is added. Remove this check once all the board
			 * implement this.
			 */
		#ifdef CONFIG_CLOCKS
			set_cpu_clk_info, /* Setup clock information */
		#endif
		#ifdef CONFIG_EFI_LOADER
			efi_memory_init,
		#endif
			initr_binman,
		#ifdef CONFIG_FSP_VERSION2
			arch_fsp_init_r,
		#endif
			initr_dm_devices,
			stdio_init_tables,
			serial_initialize,
			initr_announce,
		#if CONFIG_IS_ENABLED(WDT)
			initr_watchdog,
		#endif
			INIT_FUNC_WATCHDOG_RESET
		#if defined(CONFIG_NEEDS_MANUAL_RELOC) && defined(CONFIG_BLOCK_CACHE)
			blkcache_init,
		#endif
		#ifdef CONFIG_NEEDS_MANUAL_RELOC
			initr_manual_reloc_cmdtable,
		#endif
			arch_initr_trap,
		#if defined(CONFIG_BOARD_EARLY_INIT_R)
			board_early_init_r,
		#endif
			INIT_FUNC_WATCHDOG_RESET
		#ifdef CONFIG_POST
			post_output_backlog,
		#endif
			INIT_FUNC_WATCHDOG_RESET
		#if defined(CONFIG_PCI_INIT_R) && defined(CONFIG_SYS_EARLY_PCI_INIT)
			/*
			 * Do early PCI configuration _before_ the flash gets initialised,
			 * because PCU resources are crucial for flash access on some boards.
			 */
			pci_init,
		#endif
		#ifdef CONFIG_ARCH_EARLY_INIT_R
			arch_early_init_r,
		#endif
			power_init_board,
		#ifdef CONFIG_MTD_NOR_FLASH
			initr_flash,
		#endif
			INIT_FUNC_WATCHDOG_RESET
		#if defined(CONFIG_PPC) || defined(CONFIG_M68K) || defined(CONFIG_X86)
			/* initialize higher level parts of CPU like time base and timers */
			cpu_init_r,
		#endif
		#ifdef CONFIG_CMD_NAND
			initr_nand,
		#endif
		#ifdef CONFIG_CMD_ONENAND
			initr_onenand,
		#endif
		#ifdef CONFIG_MMC
			initr_mmc,
		#endif
		#ifdef CONFIG_XEN
			xen_init,
		#endif
		#ifdef CONFIG_PVBLOCK
			initr_pvblock,
		#endif
			initr_env,
		#ifdef CONFIG_SYS_BOOTPARAMS_LEN
			initr_malloc_bootparams,
		#endif
			INIT_FUNC_WATCHDOG_RESET
			cpu_secondary_init_r,
		#if defined(CONFIG_ID_EEPROM) || defined(CONFIG_SYS_I2C_MAC_OFFSET)
			mac_read_from_eeprom,
		#endif
			INIT_FUNC_WATCHDOG_RESET
		#if defined(CONFIG_PCI_INIT_R) && !defined(CONFIG_SYS_EARLY_PCI_INIT)
			/*
			 * Do pci configuration
			 */
			pci_init,
		#endif
			stdio_add_devices,
			jumptable_init,
		#ifdef CONFIG_API
			api_init,
		#endif
			console_init_r,		/* fully init console as a device */
		#ifdef CONFIG_DISPLAY_BOARDINFO_LATE
			console_announce_r,
			show_board_info,
		#endif
		#ifdef CONFIG_ARCH_MISC_INIT
			arch_misc_init,		/* miscellaneous arch-dependent init */
		#endif
		#ifdef CONFIG_MISC_INIT_R
			misc_init_r,		/* miscellaneous platform-dependent init */
		#endif
			INIT_FUNC_WATCHDOG_RESET
		#ifdef CONFIG_CMD_KGDB
			initr_kgdb,
		#endif
			interrupt_init,
		#if defined(CONFIG_MICROBLAZE) || defined(CONFIG_M68K)
			timer_init,		/* initialize timer */
		#endif
		#if defined(CONFIG_LED_STATUS)
			initr_status_led,
		#endif
			/* PPC has a udelay(20) here dating from 2002. Why? */
		#ifdef CONFIG_CMD_NET
			initr_ethaddr,
		#endif
		#if defined(CONFIG_GPIO_HOG)
			gpio_hog_probe_all,
		#endif
		#ifdef CONFIG_BOARD_LATE_INIT
			board_late_init,
		#endif
		#if defined(CONFIG_SCSI) && !defined(CONFIG_DM_SCSI)
			INIT_FUNC_WATCHDOG_RESET
			initr_scsi,
		#endif
		#ifdef CONFIG_BITBANGMII
			bb_miiphy_init,
		#endif
		#ifdef CONFIG_PCI_ENDPOINT
			pci_ep_init,
		#endif
		#ifdef CONFIG_CMD_NET
			INIT_FUNC_WATCHDOG_RESET
			initr_net,
		#endif
		#ifdef CONFIG_POST
			initr_post,
		#endif
		#if defined(CONFIG_IDE) && !defined(CONFIG_BLK)
			initr_ide,
		#endif
		#ifdef CONFIG_LAST_STAGE_INIT
			INIT_FUNC_WATCHDOG_RESET
			/*
			 * Some parts can be only initialized if all others (like
			 * Interrupts) are up and running (i.e. the PC-style ISA
			 * keyboard).
			 */
			last_stage_init,
		#endif
		#ifdef CONFIG_CMD_BEDBUG
			INIT_FUNC_WATCHDOG_RESET
			bedbug_init,
		#endif
		#if defined(CONFIG_PRAM)
			initr_mem,
		#endif
		#ifdef CONFIG_EFI_SETUP_EARLY
			(init_fnc_t)efi_init_obj_list,
		#endif
			run_main_loop,
		};  
跳转main_loop见代码： 
 
		static int run_main_loop(void)
		{
		#ifdef CONFIG_SANDBOX
			sandbox_main_loop_init();
		#endif
			/* main_loop() can return to retry autoboot, if so just run it again */
			for (;;)
				main_loop();
			return 0;
		}

调用时机参考：  
		void board_init_r(gd_t *new_gd, ulong dest_addr)
		{
			/*
			 * Set up the new global data pointer. So far only x86 does this
			 * here.
			 * TODO(sjg@chromium.org): Consider doing this for all archs, or
			 * dropping the new_gd parameter.
			 */
		#if CONFIG_IS_ENABLED(X86_64)
			arch_setup_gd(new_gd);
		#endif

		#ifdef CONFIG_NEEDS_MANUAL_RELOC
			int i;
		#endif

		#if !defined(CONFIG_X86) && !defined(CONFIG_ARM) && !defined(CONFIG_ARM64)
			gd = new_gd;
		#endif
			gd->flags &= ~GD_FLG_LOG_READY;

		#ifdef CONFIG_NEEDS_MANUAL_RELOC
			for (i = 0; i < ARRAY_SIZE(init_sequence_r); i++)
				init_sequence_r[i] += gd->reloc_off;
		#endif

			if (initcall_run_list(init_sequence_r))
				hang();

			/* NOTREACHED - run_main_loop() does not return */
			hang();
		}
### main_loop流程
1.设置启动次数有关参数  
2.启用Modem功能  
3.设置版本号、初始化命令自动完成等功能  
4.启动延时和启动菜单  
5.执行命令循环  
具体可参考common/main.c  

		/* We come here after U-Boot is initialised and ready to process commands */
		void main_loop(void)
		{
			const char *s;

			bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, "main_loop");

			if (IS_ENABLED(CONFIG_VERSION_VARIABLE))
				env_set("ver", version_string);  /* set version variable */

			cli_init();

			if (IS_ENABLED(CONFIG_USE_PREBOOT))
				run_preboot_environment_command();

			if (IS_ENABLED(CONFIG_UPDATE_TFTP))
				update_tftp(0UL, NULL, NULL);

			if (IS_ENABLED(CONFIG_EFI_CAPSULE_ON_DISK_EARLY))
				efi_launch_capsules();

			s = bootdelay_process();
			if (cli_process_fdt(&s))
				cli_secure_boot_cmd(s);

			autoboot_command(s);

			cli_loop();
			panic("No CLI available");
		}
