<!-- TOC -->

- [u-boot启动流程分析](#u-boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90)
    - [第一阶段](#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5)
        - [功能](#%E5%8A%9F%E8%83%BD)
        - [启动流程](#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B)
    - [第二阶段](#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5)
        - [功能](#%E5%8A%9F%E8%83%BD)
        - [运行流程](#%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B)
            - [初始化序列](#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BA%8F%E5%88%97)
                - [initrtrace](#initrtrace)
                - [initrreloc](#initrreloc)
                - [initrcaches](#initrcaches)
                - [initrrelocglobaldata](#initrrelocglobaldata)
                - [initrunlockramincache](#initrunlockramincache)
                - [initrbarrier](#initrbarrier)
                - [initrmalloc](#initrmalloc)
                - [loginit](#loginit)
                - [initrbootstage](#initrbootstage)
                - [consolerecordinit](#consolerecordinit)
                - [noncachedinit](#noncachedinit)
                - [initroflive](#initroflive)
                - [initrdm](#initrdm)
                - [initraddrmap](#initraddrmap)
                - [boardinit](#boardinit)
                - [setcpuclkinfo](#setcpuclkinfo)
                - [efimemoryinit,](#efimemoryinit)
                - [initrbinman](#initrbinman)
                - [archfspinitr,](#archfspinitr)
                - [initrdmdevices,](#initrdmdevices)
                - [stdioinittables](#stdioinittables)
                - [serialinitialize](#serialinitialize)
                - [initrannounce](#initrannounce)
                - [initrwatchdog](#initrwatchdog)
                - [blkcacheinit,](#blkcacheinit)
                - [initrmanualreloccmdtable,](#initrmanualreloccmdtable)
                - [archinitrtrap,](#archinitrtrap)
                - [boardearlyinitr,](#boardearlyinitr)
                - [postoutputbacklog,](#postoutputbacklog)
                - [pciinit,](#pciinit)
                - [archearlyinitr,](#archearlyinitr)
                - [powerinitboard,](#powerinitboard)
                - [initrflash,](#initrflash)
                - [cpuinitr,](#cpuinitr)
                - [initrnand,](#initrnand)
                - [initronenand,](#initronenand)
                - [initrmmc,](#initrmmc)
                - [xeninit,](#xeninit)
                - [initrpvblock,](#initrpvblock)
                - [initrenv,](#initrenv)
                - [initrmallocbootparams,](#initrmallocbootparams)
                - [cpusecondaryinitr,](#cpusecondaryinitr)
                - [macreadfromeeprom,](#macreadfromeeprom)
                - [pciinit,](#pciinit)
                - [stdioadddevices,](#stdioadddevices)
                - [jumptableinit,](#jumptableinit)
                - [apiinit,](#apiinit)
                - [consoleinitr,](#consoleinitr)
                - [consoleannouncer,](#consoleannouncer)
                - [showboardinfo,](#showboardinfo)
                - [archmiscinit,](#archmiscinit)
                - [miscinitr,](#miscinitr)
                - [initrkgdb,](#initrkgdb)
                - [interruptinit,](#interruptinit)
                - [timerinit,		/* initialize timer */](#timerinit%09%09-initialize-timer-)
                - [initrstatusled,](#initrstatusled)
                - [initrethaddr,](#initrethaddr)
                - [gpiohogprobeall,](#gpiohogprobeall)
                - [boardlateinit,](#boardlateinit)
                - [initrscsi,](#initrscsi)
                - [bbmiiphyinit](#bbmiiphyinit)
                - [pciepinit](#pciepinit)
                - [initrnet](#initrnet)
                - [initrpost](#initrpost)
                - [initride](#initride)
                - [laststageinit](#laststageinit)
                - [bedbuginit](#bedbuginit)
                - [initrmem](#initrmem)
                - [(initfnct)efiinitobjlist,](#initfnctefiinitobjlist)
            - [序列调用时机](#%E5%BA%8F%E5%88%97%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA)
        - [mainloop流程](#mainloop%E6%B5%81%E7%A8%8B)

<!-- /TOC -->

# u-boot启动流程分析
从上电开机执行u-boot,到u-boot加载操作系统的过程。

## 第一阶段

### 功能  
  .硬件设备初始化  
  .加载u-boot第二阶段代码到RAM空间  
  .设置好栈  
  .跳转到第二阶段代码入口  

### 启动流程
1.设置异常向量   
2.CPU进入SVC模式  
3.设置控制寄存器地址  
4.关闭看门狗  
5.屏蔽中断  
6.设置MPLLCON/UPLLCON/CLKDIVN  
7.关闭MMU和cache  
8.初始化存储控制器  
9.复制u-boot第二阶段代码到RAM  
10.设置栈  
11.清除BSS段  
12.跳转第二阶段入口

详细调用流程参考：  
**./arch/arm/cpu/armv7/start.S**

		/*************************************************************************
		 *
		 * Startup Code (reset vector)
		 *
		 * Do important init only if we don't start from memory!
		 * Setup memory and board specific bits prior to relocation.
		 * Relocate armboot to ram. Setup stack.
		 *
		 *************************************************************************/

			.globl	reset
			.globl	save_boot_params_ret
			.type   save_boot_params_ret,%function
		#ifdef CONFIG_ARMV7_LPAE
			.global	switch_to_hypervisor_ret
		#endif

		reset:
			/* Allow the board to save important registers */
			b	save_boot_params
		save_boot_params_ret:
		#ifdef CONFIG_ARMV7_LPAE
		/*
		 * check for Hypervisor support
		 */
			mrc	p15, 0, r0, c0, c1, 1		@ read ID_PFR1
			and	r0, r0, #CPUID_ARM_VIRT_MASK	@ mask virtualization bits
			cmp	r0, #(1 << CPUID_ARM_VIRT_SHIFT)
			beq	switch_to_hypervisor
		switch_to_hypervisor_ret:
		#endif
			/*
			 * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,
			 * except if in HYP mode already
			 */
			mrs	r0, cpsr
			and	r1, r0, #0x1f		@ mask mode bits
			teq	r1, #0x1a		@ test for HYP mode
			bicne	r0, r0, #0x1f		@ clear all mode bits
			orrne	r0, r0, #0x13		@ set SVC mode
			orr	r0, r0, #0xc0		@ disable FIQ and IRQ
			msr	cpsr,r0

		/*
		 * Setup vector:
		 * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
		 * Continue to use ROM code vector only in OMAP4 spl)
		 */
		#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))
			/* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */
			mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTLR Register
			bic	r0, #CR_V		@ V = 0
			mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTLR Register

		#ifdef CONFIG_HAS_VBAR
			/* Set vector address in CP15 VBAR register */
			ldr	r0, =_start
			mcr	p15, 0, r0, c12, c0, 0	@Set VBAR
		#endif
		#endif

			/* the mask ROM code should have PLL and others stable */
		#ifndef CONFIG_SKIP_LOWLEVEL_INIT
		#ifdef CONFIG_CPU_V7A
			bl	cpu_init_cp15
		#endif
		#ifndef CONFIG_SKIP_LOWLEVEL_INIT_ONLY
			bl	cpu_init_crit
		#endif
		#endif

			bl	_main

**./arch/arm/lib/crt0.S**

		ENTRY(_main)

		/*
		 * Set up initial C runtime environment and call board_init_f(0).
		 */

		#if defined(CONFIG_TPL_BUILD) && defined(CONFIG_TPL_NEEDS_SEPARATE_STACK)
			ldr	r0, =(CONFIG_TPL_STACK)
		#elif defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_STACK)
			ldr	r0, =(CONFIG_SPL_STACK)
		#else
			ldr	r0, =(CONFIG_SYS_INIT_SP_ADDR)
		#endif
			bic	r0, r0, #7	/* ##### INIT_FUNC_WATCHDOG_RESET
			/* set up gd here, outside any C code */
			mov	r9, r0
			bl	board_init_f_init_reserve

		#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_EARLY_BSS)
			CLEAR_BSS
		#endif

			mov	r0, #0
			bl	board_init_f

		#if ! defined(CONFIG_SPL_BUILD)

		/*
		 * Set up intermediate environment (new sp and gd) and call
		 * relocate_code(addr_moni). Trick here is that we'll return
		 * 'here' but relocated.
		 */

			ldr	r0, [r9, #GD_START_ADDR_SP]	/* sp = gd->start_addr_sp */
			bic	r0, r0, #7	/* 8-byte alignment for ABI compliance */
			mov	sp, r0
			ldr	r9, [r9, #GD_NEW_GD]		/* r9 <- gd->new_gd */

			adr	lr, here
			ldr	r0, [r9, #GD_RELOC_OFF]		/* r0 = gd->reloc_off */
			add	lr, lr, r0
		#if defined(CONFIG_CPU_V7M)
			orr	lr, #1				/* As required by Thumb-only */
		#endif
			ldr	r0, [r9, #GD_RELOCADDR]		/* r0 = gd->relocaddr */
			b	relocate_code
		here:
		/*
		 * now relocate vectors
		 */

			bl	relocate_vectors

		/* Set up final (full) environment */

			bl	c_runtime_cpu_setup	/* we still call old routine here */
		#endif
		#if !defined(CONFIG_SPL_BUILD) || CONFIG_IS_ENABLED(FRAMEWORK)

		#if !defined(CONFIG_SPL_BUILD) || !defined(CONFIG_SPL_EARLY_BSS)
			CLEAR_BSS
		#endif

		# ifdef CONFIG_SPL_BUILD
			/* Use a DRAM stack for the rest of SPL, if requested */
			bl	spl_relocate_stack_gd
			cmp	r0, #0
			movne	sp, r0
			movne	r9, r0
		# endif

		#if ! defined(CONFIG_SPL_BUILD)
			bl coloured_LED_init
			bl red_led_on
		#endif
			/* call board_init_r(gd_t *id, ulong dest_addr) */
			mov     r0, r9                  /* gd_t */
			ldr	r1, [r9, #GD_RELOCADDR]	/* dest_addr */
			/* call board_init_r */
		#if CONFIG_IS_ENABLED(SYS_THUMB_BUILD)
			ldr	lr, =board_init_r	/* this is auto-relocated! */
			bx	lr
		#else
			ldr	pc, =board_init_r	/* this is auto-relocated! */
		#endif
			/* we should not return here. */
		#endif

		ENDPROC(_main)

对比以上_main 执行顺序为：
 
  1. 设置调用board_init_f()的初始环境。
  本环境只提供一个栈和一个存放的地方GD（'全局数据'）结构，两者都位于一些容易可用 RAM（SRAM、锁定缓存...）。在这种情况下，变量
  全局数据，无论是否初始化（BSS），都不可用；只要CONSTANT 初始化数据可用。 GD 应归零在 board_init_f() 被调用之前。
 
  2. 调用 board_init_f()。该函数为硬件准备从系统 RAM（DRAM、DDR...）执行，因为系统 RAM 可能不会  可用，board_init_f() 必须使用当前的 GD 才能存储任何必须传递到后期阶段的数据。这些数据包括重定位目的地、未来堆栈和未来的GD位置。
 
  3. 搭建以stack和GD为核心的中间环境由 board_init_f() 在系统 RAM 中分配的，但 BSS 和初始化的非常量数据仍然不可用。
 
  4. a.对于 U-Boot 正确（非 SPL），调用 relocate_code()。这个功能将 U-Boot 从当前位置重定位到重定位目标由 board_init_f() 计算。
 
  	 b.对于 SPL，board_init_f() 仅返回（到 crt0）。没有SPL 中的代码重定位。
 
  5. 设置调用board_init_r()的最终环境。这个环境有BSS（初始化为0），初始化非常量数据（初始化为其预期值），并在系统中堆栈 RAM（对于将堆栈和 GD 移动到 RAM 中的 SPL 是可选的 。 GD 保留了由 board_init_f() 设置的值。
 
  6. 对于 U-Boot 正确（不是 SPL），一些 CPU 有一些工作要做此时关于内存，因此调用 c_runtime_cpu_setup。
 
  7. 跳转到 board_init_r()。  

对于imx6ul平台，代码路径如下：
./board/freescale/mx6ul_14x14_evk/mx6ul_14x14_evk.c中代码跳转如下：  
		void board_init_f(ulong dummy)
		{
			ccgr_init();

			/* setup AIPS and disable watchdog */
			arch_cpu_init();

			/* iomux and setup of i2c */
			board_early_init_f();

			/* setup GP timer */
			timer_init();

			/* UART clocks enabled and gd valid - init serial console */
			preloader_console_init();

			/* DDR initialization */
			spl_dram_init();

			/* Clear the BSS. */
			memset(__bss_start, 0, __bss_end - __bss_start);

			/* load/boot image from boot device */
			board_init_r(NULL, 0);
		}

## 第二阶段  

### 功能
  .初始化本阶段使用的硬件设备  
  .检测系统内存映射  
  .将内核从Flash读取到RAM中  
  .为内核设置启动参数  
  .调用内核

### 运行流程
1.板级相关初始化（board_init）  
2.时钟初始化（time_init）  
3.环境变量初始化（env_init）  
4.串口、控制台初始化（init_bandrare、serial_init、console_init_f）  
5.打印u-boot版本、编译时间等信息（display_banner)  
6.显示可用内存、显示内存大小（dram_init、display_dram_config）  
7.Nor flash初始化(flash_init)  
8.Nand Flash初始化(nand_init)  
9.调用main_loop(main_loop)

#### 初始化序列  
具体可见代码common/board_r.c中init_sequence_r定义：  

		static init_fnc_t init_sequence_r[] = {
			initr_trace,
			initr_reloc,
			/* TODO: could x86/PPC have this also perhaps? */
		#if defined(CONFIG_ARM) || defined(CONFIG_RISCV)
			initr_caches,
			/* Note: For Freescale LS2 SoCs, new MMU table is created in DDR.
			 *	 A temporary mapping of IFC high region is since removed,
			 *	 so environmental variables in NOR flash is not available
			 *	 until board_init() is called below to remap IFC to high
			 *	 region.
			 */
		#endif
			initr_reloc_global_data,
		#if defined(CONFIG_SYS_INIT_RAM_LOCK) && defined(CONFIG_E500)
			initr_unlock_ram_in_cache,
		#endif
			initr_barrier,
			initr_malloc,
			log_init,
			initr_bootstage,	/* Needs malloc() but has its own timer */
		#if defined(CONFIG_CONSOLE_RECORD)
			console_record_init,
		#endif
		#ifdef CONFIG_SYS_NONCACHED_MEMORY
			noncached_init,
		#endif
			initr_of_live,
		#ifdef CONFIG_DM
			initr_dm,
		#endif
		#ifdef CONFIG_ADDR_MAP
			initr_addr_map,
		#endif
		#if defined(CONFIG_ARM) || defined(CONFIG_NDS32) || defined(CONFIG_RISCV) || \
			defined(CONFIG_SANDBOX)
			board_init,	/* Setup chipselects */
		#endif
			/*
			 * TODO: printing of the clock inforamtion of the board is now
			 * implemented as part of bdinfo command. Currently only support for
			 * davinci SOC's is added. Remove this check once all the board
			 * implement this.
			 */
		#ifdef CONFIG_CLOCKS
			set_cpu_clk_info, /* Setup clock information */
		#endif
		#ifdef CONFIG_EFI_LOADER
			efi_memory_init,
		#endif
			initr_binman,
		#ifdef CONFIG_FSP_VERSION2
			arch_fsp_init_r,
		#endif
			initr_dm_devices,
			stdio_init_tables,
			serial_initialize,
			initr_announce,
		#if CONFIG_IS_ENABLED(WDT)
			initr_watchdog,
		#endif
			INIT_FUNC_WATCHDOG_RESET
		#if defined(CONFIG_NEEDS_MANUAL_RELOC) && defined(CONFIG_BLOCK_CACHE)
			blkcache_init,
		#endif
		#ifdef CONFIG_NEEDS_MANUAL_RELOC
			initr_manual_reloc_cmdtable,
		#endif
			arch_initr_trap,
		#if defined(CONFIG_BOARD_EARLY_INIT_R)
			board_early_init_r,
		#endif
			INIT_FUNC_WATCHDOG_RESET
		#ifdef CONFIG_POST
			post_output_backlog,
		#endif
			INIT_FUNC_WATCHDOG_RESET
		#if defined(CONFIG_PCI_INIT_R) && defined(CONFIG_SYS_EARLY_PCI_INIT)
			/*
			 * Do early PCI configuration _before_ the flash gets initialised,
			 * because PCU resources are crucial for flash access on some boards.
			 */
			pci_init,
		#endif
		#ifdef CONFIG_ARCH_EARLY_INIT_R
			arch_early_init_r,
		#endif
			power_init_board,
		#ifdef CONFIG_MTD_NOR_FLASH
			initr_flash,
		#endif
			INIT_FUNC_WATCHDOG_RESET
		#if defined(CONFIG_PPC) || defined(CONFIG_M68K) || defined(CONFIG_X86)
			/* initialize higher level parts of CPU like time base and timers */
			cpu_init_r,
		#endif
		#ifdef CONFIG_CMD_NAND
			initr_nand,
		#endif
		#ifdef CONFIG_CMD_ONENAND
			initr_onenand,
		#endif
		#ifdef CONFIG_MMC
			initr_mmc,
		#endif
		#ifdef CONFIG_XEN
			xen_init,
		#endif
		#ifdef CONFIG_PVBLOCK
			initr_pvblock,
		#endif
			initr_env,
		#ifdef CONFIG_SYS_BOOTPARAMS_LEN
			initr_malloc_bootparams,
		#endif
			INIT_FUNC_WATCHDOG_RESET
			cpu_secondary_init_r,
		#if defined(CONFIG_ID_EEPROM) || defined(CONFIG_SYS_I2C_MAC_OFFSET)
			mac_read_from_eeprom,
		#endif
			INIT_FUNC_WATCHDOG_RESET
		#if defined(CONFIG_PCI_INIT_R) && !defined(CONFIG_SYS_EARLY_PCI_INIT)
			/*
			 * Do pci configuration
			 */
			pci_init,
		#endif
			stdio_add_devices,
			jumptable_init,
		#ifdef CONFIG_API
			api_init,
		#endif
			console_init_r,		/* fully init console as a device */
		#ifdef CONFIG_DISPLAY_BOARDINFO_LATE
			console_announce_r,
			show_board_info,
		#endif
		#ifdef CONFIG_ARCH_MISC_INIT
			arch_misc_init,		/* miscellaneous arch-dependent init */
		#endif
		#ifdef CONFIG_MISC_INIT_R
			misc_init_r,		/* miscellaneous platform-dependent init */
		#endif
			INIT_FUNC_WATCHDOG_RESET
		#ifdef CONFIG_CMD_KGDB
			initr_kgdb,
		#endif
			interrupt_init,
		#if defined(CONFIG_MICROBLAZE) || defined(CONFIG_M68K)
			timer_init,		/* initialize timer */
		#endif
		#if defined(CONFIG_LED_STATUS)
			initr_status_led,
		#endif
			/* PPC has a udelay(20) here dating from 2002. Why? */
		#ifdef CONFIG_CMD_NET
			initr_ethaddr,
		#endif
		#if defined(CONFIG_GPIO_HOG)
			gpio_hog_probe_all,
		#endif
		#ifdef CONFIG_BOARD_LATE_INIT
			board_late_init,
		#endif
		#if defined(CONFIG_SCSI) && !defined(CONFIG_DM_SCSI)
			INIT_FUNC_WATCHDOG_RESET
			initr_scsi,
		#endif
		#ifdef CONFIG_BITBANGMII
			bb_miiphy_init,
		#endif
		#ifdef CONFIG_PCI_ENDPOINT
			pci_ep_init,
		#endif
		#ifdef CONFIG_CMD_NET
			INIT_FUNC_WATCHDOG_RESET
			initr_net,
		#endif
		#ifdef CONFIG_POST
			initr_post,
		#endif
		#if defined(CONFIG_IDE) && !defined(CONFIG_BLK)
			initr_ide,
		#endif
		#ifdef CONFIG_LAST_STAGE_INIT
			INIT_FUNC_WATCHDOG_RESET
			/*
			 * Some parts can be only initialized if all others (like
			 * Interrupts) are up and running (i.e. the PC-style ISA
			 * keyboard).
			 */
			last_stage_init,
		#endif
		#ifdef CONFIG_CMD_BEDBUG
			INIT_FUNC_WATCHDOG_RESET
			bedbug_init,
		#endif
		#if defined(CONFIG_PRAM)
			initr_mem,
		#endif
		#ifdef CONFIG_EFI_SETUP_EARLY
			(init_fnc_t)efi_init_obj_list,
		#endif
			run_main_loop,
		};  


##### initr_trace
初始化trace系统并使能，受CONFIG_TRACE宏控制开关

		static int initr_trace(void)
		{
		#ifdef CONFIG_TRACE
			trace_init(gd->trace_buff, CONFIG_TRACE_BUFFER_SIZE);
		#endif

			return 0;
		}
		/**
		* trace_init() - initialize the tracing system and enable it
		*
		* @buff:	Pointer to trace buffer
		* @buff_size:	Size of trace buffer
		* Return:	0 if ok
		*/
		int __attribute__((no_instrument_function)) trace_init(void *buff,
				size_t buff_size)
		{
			ulong func_count = gd->mon_len / FUNC_SITE_SIZE;
			size_t needed;
			int was_disabled = !trace_enabled;

			trace_save_gd();

			if (!was_disabled) {
		#ifdef CONFIG_TRACE_EARLY
				char *end;
				ulong used;

				/*
				* Copy over the early trace data if we have it. Disable
				* tracing while we are doing this.
				*/
				trace_enabled = 0;
				hdr = map_sysmem(CONFIG_TRACE_EARLY_ADDR,
						CONFIG_TRACE_EARLY_SIZE);
				end = (char *)&hdr->ftrace[min(hdr->ftrace_count,
								hdr->ftrace_size)];
				used = end - (char *)hdr;
				printf("trace: copying %08lx bytes of early data from %x to %08lx\n",
					used, CONFIG_TRACE_EARLY_ADDR,
					(ulong)map_to_sysmem(buff));
				memcpy(buff, hdr, used);
		#else
				puts("trace: already enabled\n");
				return -EALREADY;
		#endif
			}
			hdr = (struct trace_hdr *)buff;
			needed = sizeof(*hdr) + func_count * sizeof(uintptr_t);
			if (needed > buff_size) {
				printf("trace: buffer size %zd bytes: at least %zd needed\n",
					buff_size, needed);
				return -ENOSPC;
			}

			if (was_disabled)
				memset(hdr, '\0', needed);
			hdr->func_count = func_count;
			hdr->call_accum = (uintptr_t *)(hdr + 1);

			/* Use any remaining space for the timed function trace */
			hdr->ftrace = (struct trace_call *)(buff + needed);
			hdr->ftrace_size = (buff_size - needed) / sizeof(*hdr->ftrace);
			add_textbase();

			puts("trace: enabled\n");
			hdr->depth_limit = CONFIG_TRACE_CALL_DEPTH_LIMIT;
			trace_enabled = 1;
			trace_inited = 1;

			return 0;
		}

##### initr_reloc

		static int initr_reloc(void)
		{
			/* tell others: relocation done */
			gd->flags |= GD_FLG_RELOC | GD_FLG_FULL_MALLOC_INIT;

			return 0;
		}

##### initr_caches

		#if defined(CONFIG_ARM) || defined(CONFIG_RISCV)
		/*
		* Some of these functions are needed purely because the functions they
		* call return void. If we change them to return 0, these stubs can go away.
		*/
		static int initr_caches(void)
		{
			/* Enable caches */
			enable_caches();
			return 0;
		}
		#endif

##### initr_reloc_global_data

		__weak int fixup_cpu(void)
		{
			return 0;
		}

		static int initr_reloc_global_data(void)
		{
		#ifdef __ARM__
			monitor_flash_len = _end - __image_copy_start;
		#elif defined(CONFIG_NDS32) || defined(CONFIG_RISCV)
			monitor_flash_len = (ulong)&_end - (ulong)&_start;
		#elif !defined(CONFIG_SANDBOX) && !defined(CONFIG_NIOS2)
			monitor_flash_len = (ulong)&__init_end - gd->relocaddr;
		#endif
		#if defined(CONFIG_MPC85xx) || defined(CONFIG_MPC86xx)
			/*
			* The gd->cpu pointer is set to an address in flash before relocation.
			* We need to update it to point to the same CPU entry in RAM.
			* TODO: why not just add gd->reloc_ofs?
			*/
			gd->arch.cpu += gd->relocaddr - CONFIG_SYS_MONITOR_BASE;

			/*
			* If we didn't know the cpu mask & # cores, we can save them of
			* now rather than 'computing' them constantly
			*/
			fixup_cpu();
		#endif
		#ifdef CONFIG_SYS_RELOC_GD_ENV_ADDR
			/*
			* Relocate the early env_addr pointer unless we know it is not inside
			* the binary. Some systems need this and for the rest, it doesn't hurt.
			*/
			gd->env_addr += gd->reloc_off;
		#endif
		#ifdef CONFIG_OF_EMBED
			/*
			* The fdt_blob needs to be moved to new relocation address
			* incase of FDT blob is embedded with in image
			*/
			gd->fdt_blob += gd->reloc_off;
		#endif
		#ifdef CONFIG_EFI_LOADER
			/*
			* On the ARM architecture gd is mapped to a fixed register (r9 or x18).
			* As this register may be overwritten by an EFI payload we save it here
			* and restore it on every callback entered.
			*/
			efi_save_gd();

			efi_runtime_relocate(gd->relocaddr, NULL);
		#endif

			return 0;
		}

##### initr_unlock_ram_in_cache

		#if defined(CONFIG_SYS_INIT_RAM_LOCK) && defined(CONFIG_E500)
		static int initr_unlock_ram_in_cache(void)
		{
			unlock_ram_in_cache();	/* it's time to unlock D-cache in e500 */
			return 0;
		}
		#endif

##### initr_barrier
		static int initr_barrier(void)
		{
		#ifdef CONFIG_PPC
			/* TODO: Can we not use dmb() macros for this? */
			asm("sync ; isync");
		#endif
			return 0;
		}

##### initr_malloc
		static int initr_malloc(void)
		{
			ulong malloc_start;

		#if CONFIG_VAL(SYS_MALLOC_F_LEN)
			debug("Pre-reloc malloc() used %#lx bytes (%ld KB)\n", gd->malloc_ptr,
				gd->malloc_ptr / 1024);
		#endif
			/* The malloc area is immediately below the monitor copy in DRAM */
			/*
			* This value MUST match the value of gd->start_addr_sp in board_f.c:
			* reserve_noncached().
			*/
			malloc_start = gd->relocaddr - TOTAL_MALLOC_LEN;
			mem_malloc_init((ulong)map_sysmem(malloc_start, TOTAL_MALLOC_LEN),
					TOTAL_MALLOC_LEN);
			return 0;
		}

##### log_init

具体参见 [日志系统](./12.日志系统.md)

##### initr_bootstage

		static int initr_bootstage(void)
		{
			bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, "board_init_r");

			return 0;
		}

##### console_record_init
		int console_record_init(void)
		{
			int ret;

			ret = membuff_new((struct membuff *)&gd->console_out,
					CONFIG_CONSOLE_RECORD_OUT_SIZE);
			if (ret)
				return ret;
			ret = membuff_new((struct membuff *)&gd->console_in,
					CONFIG_CONSOLE_RECORD_IN_SIZE);

			return ret;
		}

##### noncached_init

		int noncached_init(void)
		{
			phys_addr_t start, end;
			size_t size;

			/* If this calculation changes, update board_f.c:reserve_noncached() */
			end = ALIGN(mem_malloc_start, MMU_SECTION_SIZE) - MMU_SECTION_SIZE;
			size = ALIGN(CONFIG_SYS_NONCACHED_MEMORY, MMU_SECTION_SIZE);
			start = end - size;

			debug("mapping memory %pa-%pa non-cached\n", &start, &end);

			noncached_start = start;
			noncached_end = end;
			noncached_next = start;

			noncached_set_region();

			return 0;
		}

##### initr_of_live
		static int initr_of_live(void)
		{
			if (CONFIG_IS_ENABLED(OF_LIVE)) {
				int ret;

				bootstage_start(BOOTSTAGE_ID_ACCUM_OF_LIVE, "of_live");
				ret = of_live_build(gd->fdt_blob,
							(struct device_node **)gd_of_root_ptr());
				bootstage_accum(BOOTSTAGE_ID_ACCUM_OF_LIVE);
				if (ret)
					return ret;
			}

			return 0;
		}

##### initr_dm

		#ifdef CONFIG_DM
		static int initr_dm(void)
		{
			int ret;

			/* Save the pre-reloc driver model and start a new one */
			gd->dm_root_f = gd->dm_root;
			gd->dm_root = NULL;
		#ifdef CONFIG_TIMER
			gd->timer = NULL;
		#endif
			bootstage_start(BOOTSTAGE_ID_ACCUM_DM_R, "dm_r");
			ret = dm_init_and_scan(false);
			bootstage_accum(BOOTSTAGE_ID_ACCUM_DM_R);
			if (ret)
				return ret;

			return 0;
		}
		#endif

##### initr_addr_map

		#ifdef CONFIG_ADDR_MAP
		static int initr_addr_map(void)
		{
			init_addr_map();

			return 0;
		}
		#endif

		void init_addr_map(void)
		{
			mmu_set_region_dcache_behaviour_phys(BCM2711_RPI4_PCIE_XHCI_MMIO_VIRT,
								BCM2711_RPI4_PCIE_XHCI_MMIO_PHYS,
								BCM2711_RPI4_PCIE_XHCI_MMIO_SIZE,
								DCACHE_OFF);

			/* identity mapping for 0..BCM2711_RPI4_PCIE_XHCI_MMIO_VIRT */
			addrmap_set_entry(0, 0, BCM2711_RPI4_PCIE_XHCI_MMIO_VIRT, 0);
			/* XHCI MMIO on PCIe at BCM2711_RPI4_PCIE_XHCI_MMIO_VIRT */
			addrmap_set_entry(BCM2711_RPI4_PCIE_XHCI_MMIO_VIRT,
					BCM2711_RPI4_PCIE_XHCI_MMIO_PHYS,
					BCM2711_RPI4_PCIE_XHCI_MMIO_SIZE, 1);
		}

##### board_init
		/* Setup chipselects */
		int board_init(void)
		{
			/* Address of boot parameters */
			gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;

		#ifdef	CONFIG_FEC_MXC
			setup_fec(CONFIG_FEC_ENET_DEV);
		#endif

			return 0;
		}

##### set_cpu_clk_info

##### efi_memory_init,

##### initr_binman
		static int initr_binman(void)
		{
			int ret;

			if (!CONFIG_IS_ENABLED(BINMAN_FDT))
				return 0;

			ret = binman_init();
			if (ret)
				printf("binman_init failed:%d\n", ret);

			return ret;
		}


		int binman_init(void)
		{
			int ret;

			binman = malloc(sizeof(struct binman_info));
			if (!binman)
				return log_msg_ret("space for binman", -ENOMEM);
			ret = find_image_node(&binman->image);
			if (ret)
				return log_msg_ret("node", -ENOENT);
			binman_set_rom_offset(ROM_OFFSET_NONE);
			log_debug("binman: Selected image node '%s'\n",
				ofnode_get_name(binman->image));

			return 0;
		}


##### arch_fsp_init_r,

##### initr_dm_devices,

##### stdio_init_tables

##### serial_initialize
		/**
		* serial_initialize() - Register all compiled-in serial port drivers
		*
		* This function registers all serial port drivers that are compiled
		* into the U-Boot binary with the serial core, thus making them
		* available to U-Boot to use. Lastly, this function assigns a default
		* serial port to the serial core. That serial port is then used as a
		* default output.
		*/
		int serial_initialize(void)
		{
			atmel_serial_initialize();
			mcf_serial_initialize();
			mpc85xx_serial_initialize();
			mxc_serial_initialize();
			ns16550_serial_initialize();
			pl01x_serial_initialize();
			pxa_serial_initialize();
			sh_serial_initialize();
			mtk_serial_initialize();

			serial_assign(default_serial_console()->name);

			return 0;
		}

		static struct serial_device atmel_serial_drv = {
			.name	= "atmel_serial",
			.start	= atmel_serial_init,
			.stop	= NULL,
			.setbrg	= atmel_serial_setbrg,
			.putc	= atmel_serial_putc,
			.puts	= default_serial_puts,
			.getc	= atmel_serial_getc,
			.tstc	= atmel_serial_tstc,
		};

		void atmel_serial_initialize(void)
		{
			serial_register(&atmel_serial_drv);
		}


		static struct serial_device mxc_serial_drv = {
			.name	= "mxc_serial",
			.start	= mxc_serial_init,
			.stop	= NULL,
			.setbrg	= mxc_serial_setbrg,
			.putc	= mxc_serial_putc,
			.puts	= default_serial_puts,
			.getc	= mxc_serial_getc,
			.tstc	= mxc_serial_tstc,
		};

		void mxc_serial_initialize(void)
		{
			serial_register(&mxc_serial_drv);
		}

##### initr_announce

		static int initr_announce(void)
		{
			debug("Now running in RAM - U-Boot at: %08lx\n", gd->relocaddr);
			return 0;
		}

##### initr_watchdog

		/*
		* Reset every 1000ms, or however often is required as indicated by a
		* hw_margin_ms property.
		*/
		static ulong reset_period = 1000;

		int initr_watchdog(void)
		{
			u32 timeout = WATCHDOG_TIMEOUT_SECS;
			int ret;

			/*
			* Init watchdog: This will call the probe function of the
			* watchdog driver, enabling the use of the device
			*/
			if (uclass_get_device_by_seq(UCLASS_WDT, 0,
							(struct udevice **)&gd->watchdog_dev)) {
				debug("WDT:   Not found by seq!\n");
				if (uclass_get_device(UCLASS_WDT, 0,
							(struct udevice **)&gd->watchdog_dev)) {
					printf("WDT:   Not found!\n");
					return 0;
				}
			}

			if (CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)) {
				timeout = dev_read_u32_default(gd->watchdog_dev, "timeout-sec",
								WATCHDOG_TIMEOUT_SECS);
				reset_period = dev_read_u32_default(gd->watchdog_dev,
									"hw_margin_ms",
									4 * reset_period) / 4;
			}

			if (!IS_ENABLED(CONFIG_WATCHDOG_AUTOSTART)) {
				printf("WDT:   Not starting\n");
				return 0;
			}

			ret = wdt_start(gd->watchdog_dev, timeout * 1000, 0);
			if (ret != 0) {
				printf("WDT:   Failed to start\n");
				return 0;
			}

			printf("WDT:   Started with%s servicing (%ds timeout)\n",
				IS_ENABLED(CONFIG_WATCHDOG) ? "" : "out", timeout);

			return 0;
		}


##### blkcache_init,

##### initr_manual_reloc_cmdtable,

##### arch_initr_trap,

##### board_early_init_r,

##### post_output_backlog,

##### pci_init,

##### arch_early_init_r,

##### power_init_board,

##### initr_flash,

##### cpu_init_r,

##### initr_nand,

##### initr_onenand,

##### initr_mmc,

##### xen_init,
	
##### initr_pvblock,

##### initr_env,

##### initr_malloc_bootparams,

##### cpu_secondary_init_r,
	
##### mac_read_from_eeprom,
	
##### pci_init,

##### stdio_add_devices,

##### jumptable_init,

##### api_init,

##### console_init_r,	

##### console_announce_r,

##### show_board_info,

##### arch_misc_init,		

##### misc_init_r,		

##### initr_kgdb,

##### interrupt_init,

##### timer_init,		/* initialize timer */

##### initr_status_led,

##### initr_ethaddr,

##### gpio_hog_probe_all,

##### board_late_init,

##### initr_scsi,

##### bb_miiphy_init

##### pci_ep_init


##### initr_net

##### initr_post

##### initr_ide

		#if defined(CONFIG_IDE) && !defined(CONFIG_BLK)
		static int initr_ide(void)
		{
			puts("IDE:   ");
		#if defined(CONFIG_START_IDE)
			if (board_start_ide())
				ide_init();
		#else
			ide_init();
		#endif
			return 0;
		}
		#endif

##### last_stage_init

##### bedbug_init

		/* ======================================================================
		* Initialize the bug_ctx structure used by the bedbug debugger.  This is
		* specific to the CPU since each has different debug registers and
		* settings.
		* ====================================================================== */

		int bedbug_init(void)
		{
			/* -------------------------------------------------- */
			return 0;
		}				/* bedbug_init */


##### initr_mem

		#if defined(CONFIG_PRAM)
		/*
		* Export available size of memory for Linux, taking into account the
		* protected RAM at top of memory
		*/
		int initr_mem(void)
		{
			ulong pram = 0;
			char memsz[32];

			pram = env_get_ulong("pram", 10, CONFIG_PRAM);
			sprintf(memsz, "%ldk", (long int)((gd->ram_size / 1024) - pram));
			env_set("mem", memsz);

			return 0;
		}
		#endif

##### (init_fnc_t)efi_init_obj_list,
	





#### 序列调用时机  

		void board_init_r(gd_t *new_gd, ulong dest_addr)
		{
			/*
			 * Set up the new global data pointer. So far only x86 does this
			 * here.
			 * TODO(sjg@chromium.org): Consider doing this for all archs, or
			 * dropping the new_gd parameter.
			 */
		#if CONFIG_IS_ENABLED(X86_64)
			arch_setup_gd(new_gd);
		#endif

		#ifdef CONFIG_NEEDS_MANUAL_RELOC
			int i;
		#endif

		#if !defined(CONFIG_X86) && !defined(CONFIG_ARM) && !defined(CONFIG_ARM64)
			gd = new_gd;
		#endif
			gd->flags &= ~GD_FLG_LOG_READY;

		#ifdef CONFIG_NEEDS_MANUAL_RELOC
			for (i = 0; i < ARRAY_SIZE(init_sequence_r); i++)
				init_sequence_r[i] += gd->reloc_off;
		#endif

			if (initcall_run_list(init_sequence_r))
				hang();

			/* NOTREACHED - run_main_loop() does not return */
			hang();
		}

### main_loop流程

跳转main_loop见代码： 
 
		static int run_main_loop(void)
		{
		#ifdef CONFIG_SANDBOX
			sandbox_main_loop_init();
		#endif
			/* main_loop() can return to retry autoboot, if so just run it again */
			for (;;)
				main_loop();
			return 0;
		}

1.设置启动次数有关参数  
2.启用Modem功能  
3.设置版本号、初始化命令自动完成等功能  
4.启动延时和启动菜单  
5.执行命令循环  
具体可参考common/main.c  

		/* We come here after U-Boot is initialised and ready to process commands */
		void main_loop(void)
		{
			const char *s;

			bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, "main_loop");

			if (IS_ENABLED(CONFIG_VERSION_VARIABLE))
				env_set("ver", version_string);  /* set version variable */

			cli_init();

			if (IS_ENABLED(CONFIG_USE_PREBOOT))
				run_preboot_environment_command();

			if (IS_ENABLED(CONFIG_UPDATE_TFTP))
				update_tftp(0UL, NULL, NULL);

			if (IS_ENABLED(CONFIG_EFI_CAPSULE_ON_DISK_EARLY))
				efi_launch_capsules();

			s = bootdelay_process();
			if (cli_process_fdt(&s))
				cli_secure_boot_cmd(s);

			autoboot_command(s);

			cli_loop();
			panic("No CLI available");
		}
