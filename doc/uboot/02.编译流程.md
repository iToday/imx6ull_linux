# 编译流程
编译过程分两步：
  
		1.make mx6ull_14x14_evk_defconfig   //生成.config
		2.make  //根据.config编译  

下面详细分析执行过程；
## make mx6ull_14x14_evk_defconfig流程
执行***make mx6ull_14x14_evk_defconfig V=1***查看执行过程如下 
 
		make -f ./scripts/Makefile.build obj=scripts/basic  //编译fixdep  
		...       
		make -f ./scripts/Makefile.build obj=scripts/kconfig mx6ull_14x14_evk_defconfig //编译conf   
  		...   
  		scripts/kconfig/conf  --defconfig=arch/../configs/mx6ull_14x14_evk_defconfig Kconfig  //生成.config文件  
		#  
		# configuration written to .config  
		#  

### .config 生成过程
		conf通过conf_parse(Kconfig)来解析可选的配置信息，保存到一个链表中；
		随后通过conf_read(mx6ull_14x14_evk_defconfig)读取默认的设置文件,并且生成新的配置文件；
		调用conf_set_all_new_symbols更新关系链表最后调用conf_write写入到.config中

## make流程
执行***make V=1***查看执行过程如下：  
完整日志见[make.log](./logs/make.log)，下面是过滤出来的make命令：  

		make -f ./Makefile syncconfig
		make -f ./scripts/Makefile.build obj=scripts/basic
		make -f ./scripts/Makefile.build obj=scripts/kconfig syncconfig
		make -f ./scripts/Makefile.autoconf || \
		make -f ./scripts/Makefile.build obj=scripts/basic
		make -f ./scripts/Makefile.build obj=.
		make -f ./scripts/Makefile.build obj=scripts/dtc
		make -f ./scripts/Makefile.build obj=scripts
		make -f ./scripts/Makefile.build obj=scripts/dtc
		make -f ./scripts/Makefile.build obj=tools
		make -f ./scripts/Makefile.build obj=arch/arm/cpu
		make -f ./scripts/Makefile.build obj=arch/arm/cpu/armv7
		make -f ./scripts/Makefile.build obj=arch/arm/lib
		make -f ./scripts/Makefile.build obj=arch/arm/mach-imx
		make -f ./scripts/Makefile.build obj=arch/arm/mach-imx/mx6
		make -f ./scripts/Makefile.build obj=board/freescale/common
		make -f ./scripts/Makefile.build obj=board/freescale/mx6ullevk
		make -f ./scripts/Makefile.build obj=cmd
		make -f ./scripts/Makefile.build obj=cmd/arm
		make -f ./scripts/Makefile.build obj=common
		make -f ./scripts/Makefile.build obj=common/init
		make -f ./scripts/Makefile.build obj=disk
		make -f ./scripts/Makefile.build obj=drivers
		make -f ./scripts/Makefile.build obj=drivers/adc
		make -f ./scripts/Makefile.build obj=drivers/ata
		make -f ./scripts/Makefile.build obj=drivers/axi
		make -f ./scripts/Makefile.build obj=drivers/block
		make -f ./scripts/Makefile.build obj=drivers/bus
		make -f ./scripts/Makefile.build obj=drivers/cache
		make -f ./scripts/Makefile.build obj=drivers/core
		make -f ./scripts/Makefile.build obj=drivers/crypto
		make -f ./scripts/Makefile.build obj=drivers/crypto/fsl
		make -f ./scripts/Makefile.build obj=drivers/crypto/rsa_mod_exp
		make -f ./scripts/Makefile.build obj=drivers/dfu
		make -f ./scripts/Makefile.build obj=drivers/i2c
		make -f ./scripts/Makefile.build obj=drivers/input
		make -f ./scripts/Makefile.build obj=drivers/mailbox
		make -f ./scripts/Makefile.build obj=drivers/memory
		make -f ./scripts/Makefile.build obj=drivers/misc
		make -f ./scripts/Makefile.build obj=drivers/mmc
		make -f ./scripts/Makefile.build obj=drivers/mtd
		make -f ./scripts/Makefile.build obj=drivers/mtd/nand
		make -f ./scripts/Makefile.build obj=drivers/mtd/onenand
		make -f ./scripts/Makefile.build obj=drivers/mtd/spi
		make -f ./scripts/Makefile.build obj=drivers/pinctrl
		make -f ./scripts/Makefile.build obj=drivers/pinctrl/broadcom
		make -f ./scripts/Makefile.build obj=drivers/pinctrl/nxp
		make -f ./scripts/Makefile.build obj=drivers/pwm
		make -f ./scripts/Makefile.build obj=drivers/reset
		make -f ./scripts/Makefile.build obj=drivers/rtc
		make -f ./scripts/Makefile.build obj=drivers/scsi
		make -f ./scripts/Makefile.build obj=drivers/smem
		make -f ./scripts/Makefile.build obj=drivers/soc
		make -f ./scripts/Makefile.build obj=drivers/sound
		make -f ./scripts/Makefile.build obj=drivers/spmi
		make -f ./scripts/Makefile.build obj=drivers/thermal
		make -f ./scripts/Makefile.build obj=drivers/ufs
		make -f ./scripts/Makefile.build obj=drivers/video
		make -f ./scripts/Makefile.build obj=drivers/video/bridge
		make -f ./scripts/Makefile.build obj=drivers/video/sunxi
		make -f ./scripts/Makefile.build obj=drivers/video/ti
		make -f ./scripts/Makefile.build obj=drivers/watchdog
		make -f ./scripts/Makefile.build obj=drivers/dma
		make -f ./scripts/Makefile.build obj=drivers/dma/ti
		make -f ./scripts/Makefile.build obj=drivers/gpio
		make -f ./scripts/Makefile.build obj=drivers/net
		make -f ./scripts/Makefile.build obj=drivers/net/mscc_eswitch
		make -f ./scripts/Makefile.build obj=drivers/net/qe
		make -f ./scripts/Makefile.build obj=drivers/net/ti
		make -f ./scripts/Makefile.build obj=drivers/net/phy
		make -f ./scripts/Makefile.build obj=drivers/power
		make -f ./scripts/Makefile.build obj=drivers/power/battery
		make -f ./scripts/Makefile.build obj=drivers/power/domain
		make -f ./scripts/Makefile.build obj=drivers/power/fuel_gauge
		make -f ./scripts/Makefile.build obj=drivers/power/mfd
		make -f ./scripts/Makefile.build obj=drivers/power/pmic
		make -f ./scripts/Makefile.build obj=drivers/power/regulator
		make -f ./scripts/Makefile.build obj=drivers/serial
		make -f ./scripts/Makefile.build obj=drivers/spi
		make -f ./scripts/Makefile.build obj=drivers/usb/cdns3
		make -f ./scripts/Makefile.build obj=drivers/usb/common
		make -f ./scripts/Makefile.build obj=drivers/usb/dwc3
		make -f ./scripts/Makefile.build obj=drivers/usb/emul
		make -f ./scripts/Makefile.build obj=drivers/usb/eth
		make -f ./scripts/Makefile.build obj=drivers/usb/host
		make -f ./scripts/Makefile.build obj=drivers/usb/mtu3
		make -f ./scripts/Makefile.build obj=drivers/usb/musb-new
		make -f ./scripts/Makefile.build obj=drivers/usb/musb
		make -f ./scripts/Makefile.build obj=drivers/usb/phy
		make -f ./scripts/Makefile.build obj=drivers/usb/ulpi
		make -f ./scripts/Makefile.build obj=env
		make -f ./scripts/Makefile.build obj=fs
		make -f ./scripts/Makefile.build obj=fs/ext4
		make -f ./scripts/Makefile.build obj=fs/fat
		make -f ./scripts/Makefile.build obj=lib
		make -f ./scripts/Makefile.build obj=lib/crypto
		make -f ./scripts/Makefile.build obj=lib/efi_driver
		make -f ./scripts/Makefile.build obj=lib/efi_loader
		make -f ./scripts/Makefile.build obj=lib/libfdt
		make -f ./scripts/Makefile.build obj=lib/zlib
		make -f ./scripts/Makefile.build obj=net
		make -f ./scripts/Makefile.build obj=examples
		make -f ./scripts/Makefile.build obj=dts dtbs
		make -f ./scripts/Makefile.build obj=arch/arm/dts dtbs
		make -f ./scripts/Makefile.build obj=arch/arm/mach-imx u-boot-dtb.imx
 
从make执行的顺序发现，依次编译了下面目录：

		scripts
		tools
		arch
			arm/cpu
			arm/cpu/armv7
			arm/lib
			arm/mach-imx
			arm/mach-imx/mx6
		board
			freescale/common
			freescale/mx6ullevk
		cmd
		common
		disk
		drivers
		env
		fs
		lib
		net
		examples
		dts 
		arch
			arm/dts 
			arm/mach-imx

下面逐一分析：  
### scripts
目录下包含basic、dtc、kconfig子目录，分别编译出fixdep、dtc、conf执行程序，其中fixdep&conf在make mx6ull_14x14_evk_defconfig时已经编译；  

下面是三条命令的使用基本方法： 
 
		fixdep <depfile> <target> <cmdline>  
		dtc [options] <input file>  
		conf [-s] [option] <kconfig-file>  

### tools

目录编译出下面可执行程序：

|命令|作用|
| ----------- | ----------- |
| dumpimage      | 解析itb，抽取内部文件       |
| fdtgrep   | U-Boot 设备树在构建过程中被 fdtgrep 工具过滤生成 SPL 中使用的更小的设备树的过程 (spl/u-boot-spl.dtb)和：- 强制节点（/alias、/chosen、/config）- 具有一个预重定位属性的节点：'u-boot,dm-pre-reloc' 或 'u-boot,dm-spl' fdtgrep 也用于删除：- CONFIG_OF_SPL_REMOVE_PROPS 中定义的属性        |
|fit_check_sign|检查FIT IMG的签名|
|fit_info|打印FIT文件中节点的偏移位置和长度信息|
|gen_eth_addr|生成MAC地址|
|gen_ethaddr_crc|获取MAC地址CRC校验|
|img2srec|用于将 Linux 启动映像 (zimage.initrd) 转换为用于闪存编程的 S-Record 格式|
|mkimage|用于创建 U-Boot 引导加载程序的映像；这些镜像可以包含 linux 内核、设备树 blob、根文件系统映像、固件映像等，可以是单独的，也可以是组合的|
|proftool|解析打印 U-Boot 信息|
|spl_size_limit|在构建期间返回可用于 SPL 图像的大小|


### arch
arch目录存放支持的处理器指令集，常见嵌入式处理指令集arm/mips,根据自己处理器的指令集修改对应的目录  

		tudou@tudou-YangTianA7000t-01:~/work/code/imx6ull_linux/u-boot-2021.10$ ls arch/ -l  
		总用量 64  
		drwxrwxr-x  6 tudou tudou 4096 10月  8 09:45 arc  
		drwxrwxr-x 49 tudou tudou 4096 10月  8 09:45 arm  
		-rw-rw-r--  1 tudou tudou 7358 10月  8 09:45 Kconfig  
		drwxrwxr-x  6 tudou tudou 4096 10月  8 09:45 m68k  
		drwxrwxr-x  6 tudou tudou 4096 10月  8 09:45 microblaze  
		drwxrwxr-x 13 tudou tudou 4096 10月  8 09:45 mips  
		drwxrwxr-x  6 tudou tudou 4096 10月  8 09:45 nds32  
		drwxrwxr-x  6 tudou tudou 4096 10月  8 09:45 nios2  
		drwxrwxr-x  6 tudou tudou 4096 10月  8 09:45 powerpc  
		drwxrwxr-x  6 tudou tudou 4096 10月  8 09:45 riscv  
		drwxrwxr-x  6 tudou tudou 4096 10月  8 09:45 sandbox  
		drwxrwxr-x  6 tudou tudou 4096 10月  8 09:45 sh  
		-rw-rw-r--  1 tudou tudou  103 10月  8 09:45 u-boot-elf.lds  
		drwxrwxr-x  6 tudou tudou 4096 10月  8 09:45 x86  
		drwxrwxr-x  6 tudou tudou 4096 10月  8 09:45 xtensa  

### board
board目录存放的是各个厂家的开发板相关文件,移植重点修改的目录；如NXP的IMX6ULL开发板：  
ls ./board/freescale/mx6ullevk/ -l  
总用量 104  

		-rw-rw-r-- 1 tudou tudou  2787 10月  8 09:45 imximage.cfg  
		-rw-rw-r-- 1 tudou tudou   158 10月  8 09:45 Kconfig  
		-rw-rw-r-- 1 tudou tudou   243 10月  8 09:45 MAINTAINERS  
		-rw-rw-r-- 1 tudou tudou   110 10月  8 09:45 Makefile  
		-rw-rw-r-- 1 tudou tudou  3070 10月  8 09:45 mx6ullevk.c  
		-rw-rw-r-- 1 tudou tudou  2715 10月  8 09:45 plugin.S  

### cmd  
cmd目录下编译出来是uboot支持的命令，这些命令并非我们常见的独立的可执行程序；所有命令都编译在uboot中，通过 **grep -rn  u_boot_list_2_cmd_2 ./u-boot.map**可以查看当前编译的uboot支持哪些命令，如下：  

		./u-boot.map:10684: .rel.u_boot_list_2_cmd_2_bmode
		./u-boot.map:10722: .rel.u_boot_list_2_cmd_2_clocks
		./u-boot.map:10734: .rel.u_boot_list_2_cmd_2_go
		./u-boot.map:10736: .rel.u_boot_list_2_cmd_2_reset
		./u-boot.map:10750: .rel.u_boot_list_2_cmd_2_boot
		./u-boot.map:10752: .rel.u_boot_list_2_cmd_2_bootd
		./u-boot.map:10754: .rel.u_boot_list_2_cmd_2_bootm
		./u-boot.map:10756: .rel.u_boot_list_2_cmd_2_iminfo
		./u-boot.map:10760: .rel.u_boot_list_2_cmd_2_help
		./u-boot.map:10762: .rel.u_boot_list_2_cmd_2_question_mark
		./u-boot.map:10766: .rel.u_boot_list_2_cmd_2_panic
		./u-boot.map:10770: .rel.u_boot_list_2_cmd_2_version
		./u-boot.map:10776: .rel.u_boot_list_2_cmd_2_source
		./u-boot.map:10784: .rel.u_boot_list_2_cmd_2_bdinfo
		./u-boot.map:10794: .rel.u_boot_list_2_cmd_2_blkcache
		./u-boot.map:10808: .rel.u_boot_list_2_cmd_2_bootefi
		./u-boot.map:10812: .rel.u_boot_list_2_cmd_2_bootz
		./u-boot.map:10820: .rel.u_boot_list_2_cmd_2_dcache
		./u-boot.map:10822: .rel.u_boot_list_2_cmd_2_icache
		./u-boot.map:10826: .rel.u_boot_list_2_cmd_2_coninfo
		./u-boot.map:10832: .rel.u_boot_list_2_cmd_2_dm
		./u-boot.map:10836: .rel.u_boot_list_2_cmd_2_echo
		./u-boot.map:10842: .rel.u_boot_list_2_cmd_2_bootelf
		./u-boot.map:10844: .rel.u_boot_list_2_cmd_2_bootvx
		./u-boot.map:10846: .rel.u_boot_list_2_cmd_2_exit
		./u-boot.map:10848: .rel.u_boot_list_2_cmd_2_ext4load
		./u-boot.map:10850: .rel.u_boot_list_2_cmd_2_ext4ls
		./u-boot.map:10852: .rel.u_boot_list_2_cmd_2_ext4size
		./u-boot.map:10854: .rel.u_boot_list_2_cmd_2_ext4write
		./u-boot.map:10856: .rel.u_boot_list_2_cmd_2_ext2load
		./u-boot.map:10858: .rel.u_boot_list_2_cmd_2_ext2ls
		./u-boot.map:10862: .rel.u_boot_list_2_cmd_2_fatinfo
		./u-boot.map:10864: .rel.u_boot_list_2_cmd_2_fatload
		./u-boot.map:10866: .rel.u_boot_list_2_cmd_2_fatls
		./u-boot.map:10868: .rel.u_boot_list_2_cmd_2_fatmkdir
		./u-boot.map:10870: .rel.u_boot_list_2_cmd_2_fatrm
		./u-boot.map:10872: .rel.u_boot_list_2_cmd_2_fatsize
		./u-boot.map:10874: .rel.u_boot_list_2_cmd_2_fatwrite
		./u-boot.map:10886: .rel.u_boot_list_2_cmd_2_fdt
		./u-boot.map:10888: .rel.u_boot_list_2_cmd_2_erase
		./u-boot.map:10890: .rel.u_boot_list_2_cmd_2_flinfo
		./u-boot.map:10892: .rel.u_boot_list_2_cmd_2_protect
		./u-boot.map:10894: .rel.u_boot_list_2_cmd_2_fstype
		./u-boot.map:10896: .rel.u_boot_list_2_cmd_2_fstypes
		./u-boot.map:10898: .rel.u_boot_list_2_cmd_2_ln
		./u-boot.map:10900: .rel.u_boot_list_2_cmd_2_load
		./u-boot.map:10902: .rel.u_boot_list_2_cmd_2_ls
		./u-boot.map:10904: .rel.u_boot_list_2_cmd_2_save
		./u-boot.map:10906: .rel.u_boot_list_2_cmd_2_size
		./u-boot.map:10910: .rel.u_boot_list_2_cmd_2_fuse
		./u-boot.map:10916: .rel.u_boot_list_2_cmd_2_gpio
		./u-boot.map:10954: .rel.u_boot_list_2_cmd_2_i2c
		./u-boot.map:10962: .rel.u_boot_list_2_cmd_2_itest
		./u-boot.map:10984: .rel.u_boot_list_2_cmd_2_loadb
		./u-boot.map:10986: .rel.u_boot_list_2_cmd_2_loads
		./u-boot.map:10988: .rel.u_boot_list_2_cmd_2_loadx
		./u-boot.map:10990: .rel.u_boot_list_2_cmd_2_loady
		./u-boot.map:11010: .rel.u_boot_list_2_cmd_2_base
		./u-boot.map:11012: .rel.u_boot_list_2_cmd_2_cmp
		./u-boot.map:11014: .rel.u_boot_list_2_cmd_2_cp
		./u-boot.map:11016: .rel.u_boot_list_2_cmd_2_crc32
		./u-boot.map:11018: .rel.u_boot_list_2_cmd_2_loop
		./u-boot.map:11020: .rel.u_boot_list_2_cmd_2_md
		./u-boot.map:11022: .rel.u_boot_list_2_cmd_2_mm
		./u-boot.map:11024: .rel.u_boot_list_2_cmd_2_mtest
		./u-boot.map:11026: .rel.u_boot_list_2_cmd_2_mw
		./u-boot.map:11028: .rel.u_boot_list_2_cmd_2_nm
		./u-boot.map:11030: .rel.u_boot_list_2_cmd_2_random
		./u-boot.map:11032: .rel.u_boot_list_2_cmd_2_sleep
		./u-boot.map:11062: .rel.u_boot_list_2_cmd_2_mmc
		./u-boot.map:11064: .rel.u_boot_list_2_cmd_2_mmcinfo
		./u-boot.map:11080: .rel.u_boot_list_2_cmd_2_bootp
		./u-boot.map:11082: .rel.u_boot_list_2_cmd_2_dhcp
		./u-boot.map:11084: .rel.u_boot_list_2_cmd_2_net
		./u-boot.map:11086: .rel.u_boot_list_2_cmd_2_nfs
		./u-boot.map:11088: .rel.u_boot_list_2_cmd_2_ping
		./u-boot.map:11090: .rel.u_boot_list_2_cmd_2_tftpboot
		./u-boot.map:11104: .rel.u_boot_list_2_cmd_2_pinmux
		./u-boot.map:11108: .rel.u_boot_list_2_cmd_2_sf
		./u-boot.map:11122: .rel.u_boot_list_2_cmd_2_setexpr
		./u-boot.map:11128: .rel.u_boot_list_2_cmd_2_false
		./u-boot.map:11130: .rel.u_boot_list_2_cmd_2_test
		./u-boot.map:11132: .rel.u_boot_list_2_cmd_2_true
		./u-boot.map:11136: .rel.u_boot_list_2_cmd_2_imxtract
		./u-boot.map:11172: .rel.u_boot_list_2_cmd_2_editenv
		./u-boot.map:11174: .rel.u_boot_list_2_cmd_2_env
		./u-boot.map:11176: .rel.u_boot_list_2_cmd_2_printenv
		./u-boot.map:11178: .rel.u_boot_list_2_cmd_2_run
		./u-boot.map:11180: .rel.u_boot_list_2_cmd_2_saveenv
		./u-boot.map:11182: .rel.u_boot_list_2_cmd_2_setenv
		./u-boot.map:11224: .rel.u_boot_list_2_cmd_2_showvar

具体编译过程及cmd机制可参考https://blog.csdn.net/qq_33894122/article/details/86129765  
### common
包含了main入口及后续的启动流程；
### disk
主要分区管理代码，用于支持不同格式的分区    

		part.c：输出设备信息  
		part_amiga.c：处理amiga分区  
		part_dos.c：处理dos分区  
		part_iso.c：处理iso分区  
		part_mac.c：处理mac分区  
### drivers
通过**grep -r _u_boot_list_2_driver_2 ./u-boot.map** 查看当前支持的驱动如下：  

		0x0000000087849c50                _u_boot_list_2_driver_2_74x164  
		0x0000000087849c94                _u_boot_list_2_driver_2_efi_blk  
		0x0000000087849cd8                _u_boot_list_2_driver_2_efi_block  
		0x0000000087849d1c                _u_boot_list_2_driver_2_eth_phy_generic_drv  
		0x0000000087849d60                _u_boot_list_2_driver_2_fecmxc_gem  
		0x0000000087849da4                _u_boot_list_2_driver_2_fsl_esdhc  
		0x0000000087849de8                _u_boot_list_2_driver_2_fsl_imx6q_iomuxc  
		0x0000000087849e2c                _u_boot_list_2_driver_2_fsl_qspi  
		0x0000000087849e70                _u_boot_list_2_driver_2_gpio_mxc  
		0x0000000087849eb4                _u_boot_list_2_driver_2_gpio_regulator  
		0x0000000087849ef8                _u_boot_list_2_driver_2_i2c_generic_chip_drv  
		0x0000000087849f3c                _u_boot_list_2_driver_2_i2c_mxc  
		0x0000000087849f80                _u_boot_list_2_driver_2_imx_thermal  
		0x0000000087849fc4                _u_boot_list_2_driver_2_jedec_spi_nor  
		0x000000008784a008                _u_boot_list_2_driver_2_mmc_blk  
		0x000000008784a04c                _u_boot_list_2_driver_2_pinconfig_generic  
		0x000000008784a090                _u_boot_list_2_driver_2_regulator_fixed  
		0x000000008784a0d4                _u_boot_list_2_driver_2_root_driver  
		0x000000008784a118                _u_boot_list_2_driver_2_simple_bus  
		0x000000008784a15c                _u_boot_list_2_driver_2_soft_spi  
		0x000000008784a1a0                _u_boot_list_2_driver_2_spi_generic_drv  

驱动框架参考如下：https://cloud.tencent.com/developer/article/1571947  

### env
通过**grep -r _u_boot_list_2_env ./u-boot.map** 查看当前  

        0x000000008784a1ec                _u_boot_list_2_env_clbk_2_baudrate  
        0x000000008784a1f4                _u_boot_list_2_env_clbk_2_callbacks  
        0x000000008784a1fc                _u_boot_list_2_env_clbk_2_console  
        0x000000008784a204                _u_boot_list_2_env_clbk_2_ethaddr  
        0x000000008784a20c                _u_boot_list_2_env_clbk_2_flags  
        0x000000008784a214                _u_boot_list_2_env_clbk_2_gatewayip  
        0x000000008784a21c                _u_boot_list_2_env_clbk_2_ipaddr  
        0x000000008784a224                _u_boot_list_2_env_clbk_2_loadaddr  
        0x000000008784a22c                _u_boot_list_2_env_clbk_2_netmask  
        0x000000008784a234                _u_boot_list_2_env_clbk_2_nvlan  
        0x000000008784a23c                _u_boot_list_2_env_clbk_2_serverip  
        0x000000008784a244                _u_boot_list_2_env_clbk_2_vlan  
        0x000000008784a24c                _u_boot_list_2_env_driver_2_mmc  


### fs
查看fs/fs.c中结构体定义，支持下面几种文件类型：  

	static struct fstype_info fstypes[] = {
	#ifdef CONFIG_FS_FAT
		{
			.fstype = FS_TYPE_FAT,
			.name = "fat",
			.null_dev_desc_ok = false,
			.probe = fat_set_blk_dev,
			.close = fat_close,
			.ls = fs_ls_generic,
			.exists = fat_exists,
			.size = fat_size,
			.read = fat_read_file,
	#if CONFIG_IS_ENABLED(FAT_WRITE)
			.write = file_fat_write,
			.unlink = fat_unlink,
			.mkdir = fat_mkdir,
	#else
			.write = fs_write_unsupported,
			.unlink = fs_unlink_unsupported,
			.mkdir = fs_mkdir_unsupported,
	#endif
			.uuid = fat_uuid,
			.opendir = fat_opendir,
			.readdir = fat_readdir,
			.closedir = fat_closedir,
			.ln = fs_ln_unsupported,
		},
	#endif

	#if CONFIG_IS_ENABLED(FS_EXT4)
		{
			.fstype = FS_TYPE_EXT,
			.name = "ext4",
			.null_dev_desc_ok = false,
			.probe = ext4fs_probe,
			.close = ext4fs_close,
			.ls = ext4fs_ls,
			.exists = ext4fs_exists,
			.10386:                0x0000000087849c50                
			.size = ext4fs_size,
			.read = ext4_read_file,
	#ifdef CONFIG_CMD_EXT4_WRITE
			.write = ext4_write_file,
			.ln = ext4fs_create_link,
	#else
			.write = fs_write_unsupported,
			.ln = fs_ln_unsupported,
	#endif
			.uuid = ext4fs_uuid,
			.opendir = fs_opendir_unsupported,
			.unlink = fs_unlink_unsupported,
			.mkdir = fs_mkdir_unsupported,
		},
	#endif
	#ifdef CONFIG_SANDBOX
		{
			.fstype = FS_TYPE_SANDBOX,
			.name = "sandbox",
			.null_dev_desc_ok = true,
			.probe = sandbox_fs_set_blk_dev,
			.close = sandbox_fs_close,
			.ls = sandbox_fs_ls,
			.exists = sandbox_fs_exists,
			.size = sandbox_fs_size,
			.read = fs_read_sandbox,
			.write = fs_write_sandbox,
			.uuid = fs_uuid_unsupported,
			.opendir = fs_opendir_unsupported,
			.unlink = fs_unlink_unsupported,
			.mkdir = fs_mkdir_unsupported,
			.ln = fs_ln_unsupported,
		},
	#endif
	#ifdef CONFIG_CMD_UBIFS
		{
			.fstype = FS_TYPE_UBIFS,
			.name = "ubifs",
			.null_dev_desc_ok = true,
			.probe = ubifs_set_blk_dev,
			.close = ubifs_close,
			.ls = ubifs_ls,
			.exists = ubifs_exists,
			.size = ubifs_size,
			.read = ubifs_read,
			.write = fs_write_unsupported,
			.uuid = fs_uuid_unsupported,
			.opendir = fs_opendir_unsupported,
			.unlink = fs_unlink_unsupported,
			.mkdir = fs_mkdir_unsupported,
			.ln = fs_ln_unsupported,
		},
	#endif
	#ifdef CONFIG_FS_BTRFS
		{
			.fstype = FS_TYPE_BTRFS,
			.name = "btrfs",
			.null_dev_desc_ok = false,
			.probe = btrfs_probe,
			.close = btrfs_close,
			.ls = btrfs_ls,
			.exists = btrfs_exists,
			.size = btrfs_size,
			.read = btrfs_read,
			.write = fs_write_unsupported,
			.uuid = btrfs_uuid,
			.opendir = fs_opendir_unsupported,
			.unlink = fs_unlink_unsupported,
			.mkdir = fs_mkdir_unsupported,
			.ln = fs_ln_unsupported,
		},
	#endif
	#if IS_ENABLED(CONFIG_FS_SQUASHFS)
		{
			.fstype = FS_TYPE_SQUASHFS,
			.name = "squashfs",
			.null_dev_desc_ok = false,
			.probe = sqfs_probe,
			.opendir = sqfs_opendir,
			.readdir = sqfs_readdir,
			.ls = fs_ls_generic,
			.read = sqfs_read,
			.size = sqfs_size,
			.close = sqfs_close,
			.closedir = sqfs_closedir,
			.exists = sqfs_exists,
			.uuid = fs_uuid_unsupported,
			.write = fs_write_unsupported,
			.ln = fs_ln_unsupported,
			.unlink = fs_unlink_unsupported,
			.mkdir = fs_mkdir_unsupported,
		},
	#endif
		{
			.fstype = FS_TYPE_ANY,
			.name = "unsupported",
			.null_dev_desc_ok = true,
			.probe = fs_probe_unsupported,
			.close = fs_close_unsupported,
			.ls = fs_ls_unsupported,
			.exists = fs_exists_unsupported,
			.size = fs_size_unsupported,
			.read = fs_read_unsupported,
			.write = fs_write_unsupported,
			.uuid = fs_uuid_unsupported,
			.opendir = fs_opendir_unsupported,
			.unlink = fs_unlink_unsupported,
			.mkdir = fs_mkdir_unsupported,
			.ln = fs_ln_unsupported,
		},
	};

后续学习文件系统内容时，可参考；  

### lib

		acpi:高级配置与电源接口
		aes:高级加密标准
		at91:atmel at91系列芯片
		bzip2：bz2文件压缩解压
		crypt:加密sha256/sha512
		crypto:加密rsa/x509/pkcs7
		dhry:支持 'dhry' 命令来运行 dhrystone 基准测试
		ecdsa:椭圆曲线签名,为 FIT 启用 ECDSA（椭圆曲线签名）算法U-Boot 中的图像验证
		efi:可扩展固件接口(英文名Extensible Firmware Interface 或EFI)  
		libavb:Android Verified Boot  
		libfdt:flatted device tree，扁平设备树  
		lzma:LZ77压缩算法改进的压缩/解压工具，特点：高压缩率，高解压速度，低内存消耗  
		lzo:致力于解压速度的一种数据压缩算法  
		optee:OP-TEE 安全的环境 
		tizen:三星tizen操作系统 
		bch:该库提供运行时可配置的二进制编码/解码Bose-Chaudhuri-Hocquenghem (BCH) 代码。
		binman:用于创建固件image的工具,它提供了一种将各种二进制文件组合在一起并将它们放置在图像中、特定位置和可配置对齐方式的方法。  
		bitrev:bit位翻转
		charset:UTF字符处理
		circbuf:环形BUF
		crc7、crc8、	crc32、crc32c:CRC算法
		ctype:字符处理
		date:时间处理
		hang:保持无限循环来停止处理
		hashtable:哈希表
		hexdump:十六进制打印
		image-sparse:sparse是一种稀疏的文件描述格式，size比ext4的要小很多，而ext4格式的文件中有很多零填充
		lmb:logical memory blocks
		lz4:快速LZ压缩算法
		md5:MD5计算
		net_utils:通用网络代码
		old_registry:ASN.1 对象标识符 (OID) 注册表
		panic:异常打印
		rational：计算给定分数的最佳有理近似值
		rbtree:红黑树	
		smbios:SMBIOS(System Management BIOS)是主板或系统制造者以标准格式显示产品管理信息所需遵循的统一规范		
		tpm:可信平台模块(Trusted Platform Module),是一项安全密码处理器的国际标准,通过在设备中集成的专用安全硬件来处理设备中的加密密钥
		uuid:uuid相关操作
		vsprintf:printf相关函数
		xxhash:极快的哈希算法

### net
参考下面链接https://www.eet-china.com/mp/a13673.html  
### examples

### dts
用于构建内部 U-Boot fdt(flatted device tree，扁平设备树)；构建流程梳理如下：

		LDS     u-boot.lds
		LD      u-boot
		OBJCOPY u-boot-nodtb.bin
		DTC     arch/arm/dts/imx6ull-14x14-evk.dtb
		DTC     arch/arm/dts/imx6ull-colibri.dtb
		DTC     arch/arm/dts/imx6ull-myir-mys-6ulx-eval.dtb
		DTC     arch/arm/dts/imx6ull-seeed-npi-imx6ull-dev-board.dtb
		DTC     arch/arm/dts/imx6ull-phytec-segin-ff-rdk-emmc.dtb
		DTC     arch/arm/dts/imx6ull-dart-6ul.dtb
		DTC     arch/arm/dts/imx6ull-somlabs-visionsom.dtb
		DTC     arch/arm/dts/imx6ulz-14x14-evk.dtb
		DTC     arch/arm/dts/imx6-apalis.dtb
		DTC     arch/arm/dts/imx6-colibri.dtb
		SHIPPED dts/dt.dtb
		CAT     u-boot-dtb.bin
		CFGS    u-boot-dtb.cfgout
		MKIMAGE u-boot-dtb.imx
		OBJCOPY u-boot.srec
		COPY    u-boot.bin
		SYM     u-boot.sym
		COPY    u-boot.dtb

fdt 源文件是dts,通过dtc编译后为dtb文件，对设备数的二进制和文件源文件两种格式可以用ftdgrep(源码见./tools/ftdgrep.c)进行读写

uboot里面，在设备的deconfig里通过CONFIG_DEFAULT_DEVICE_TREE="xxxxx"来指定。

如果设置CONFIG_OF_EMBED，那么uboot会把设备树编译进镜像内。

如果设置CONFIG_OF_SEPARATE，则直接用cat u-boot.bin u-boot.dtb >image.bin这样的方式把设备树放在uboot镜像后面。

.dts:　device tree source   
.dtsi:   device tree source include  
.dts比作源文件，.dtsi比作头文件。  
.dtc是linux源码 /scripts/dtc 目录下的工具，它把.dts编译成 .dtb。  
.dtb是.dts被DTC编译后的二进制格式的DeviceTree描述，可由Linux内核解析，bootloader在引导kernel的过程中，会先读取该.dtb到内存。  

#### dts文件分析
dts文件的基本组成单元为

		[label:] node-name[@unit-address] { 
			[properties definitions]          //就是属性定义，对当前节点描述，将硬件信息提供给内核处理
			[child nodes]                     //子节点 
		}

在dts文件中，对于properties，有一些常用的、默认的、特殊的属性，定义如下：

model  
        设备制造商的描述，如果有2款板子配置基本一致, 它们的compatible是一样的那么就通过model来分辨这2款板子  
compatible  
        定义一系列的字符串, 用来指定内核中哪个machine_desc可以支持本设备，即这个板子兼容哪些平台 。一般"供应商，产品"。  
reg             
        描述设备资源在其父总线定义的地址空间中的地址。通常这意味着内存映射IO寄存器块的偏移量和长度，但在某些总线类型上可能有不同的含义。根节点定义的地址空间中的地址是CPU实际地址。  
#address-cells  
       在它的子节点的reg属性中, 使用多少个u32整数来描述地址(address)
#size-cells   
      在它的子节点的reg属性中, 使用多少个u32整数来描述地址长度(size)  
phandle  
      节点中的phandle属性, 它的取值必须是唯一的(不要跟其他的phandle值一样)，使用phandle值来引用节点  
bootargs  
      内核command line参数, 跟u-boot中设置的bootargs作用一样   
cpus  
  /cpus节点下面有1个或多个cpu子节点，cpu子节点用reg属性来表明自己是那个cpu  

##### dts/dtsi规则

**覆盖规则**

同一层次的节点，后面的会覆盖前面的节点。


		memory@30000000 {
			device_type = "memory";
			reg = <0x30000000 0x20000000>;
		};  
		memory@30000000 {
			reg = <0x30000000 0x10000000>;
		};

编译后，查看结果如下：

		memory@30000000 {
			device_type = "memory";
			reg = <0x30000000 0x10000000>;
		}; 

**直接引用方式覆盖（增加）节点属性**
假设下面节点定义在dtsi文件中

		xusbxti: oscillator@1 {
					compatible = "fixed-clock";
					reg = <1>;
					clock-frequency = <0>;
					clock-output-names = "xusbxti";
					#clock-cells = <0>;
				};
某个dts文件包含了该dtsi文件，并定义了如下内容

		&xusbxti {
			clock-frequency = <24000000>;
		};

编译后，查看结果如下:

		xusbxti: oscillator@1 {
					compatible = "fixed-clock";
					reg = <1>;
					clock-frequency = <0x16e3600>;
					clock-output-names = "xusbxti";
					#clock-cells = <0>;
				};

<font color=Crimson>对于同一个节点的设置情况，dts中的配置会覆盖dtsi中的配置</font>

#### DTC处理dts流程

DTC命令执行入口如下：
		int main(int argc, char *argv[]){
			...
			if (streq(outform, "dts")) {
				dt_to_source(outf, dti);
			} else if (streq(outform, "dtb")) {
				dt_to_blob(outf, dti, outversion);
			} else if (streq(outform, "asm")) {
				dt_to_asm(outf, dti, outversion);
			} else if (streq(outform, "null")) {
				/* do nothing */
			} else {
				die("Unknown output format \"%s\"\n", outform);
			}

			exit(0);
		}

我们在此只分析dts转dtb的流程，参见下面函数dt_to_blob；

		void dt_to_blob(FILE *f, struct dt_info *dti, int version)
		{
			struct version_info *vi = NULL;
			int i;
			struct data blob       = empty_data;
			struct data reservebuf = empty_data;
			struct data dtbuf      = empty_data;
			struct data strbuf     = empty_data;
			struct fdt_header fdt;
			int padlen = 0;

			for (i = 0; i < ARRAY_SIZE(version_table); i++) {
				if (version_table[i].version == version)
					vi = &version_table[i];
			}
			if (!vi)
				die("Unknown device tree blob version %d\n", version);

			flatten_tree(dti->dt, &bin_emitter, &dtbuf, &strbuf, vi);
			bin_emit_cell(&dtbuf, FDT_END);

			reservebuf = flatten_reserve_list(dti->reservelist, vi);

			/* Make header */
			make_fdt_header(&fdt, vi, reservebuf.len, dtbuf.len, strbuf.len,
					dti->boot_cpuid_phys);

			/*
			* If the user asked for more space than is used, adjust the totalsize.
			*/
			if (minsize > 0) {
				padlen = minsize - fdt32_to_cpu(fdt.totalsize);
				if (padlen < 0) {
					padlen = 0;
					if (quiet < 1)
						fprintf(stderr,
							"Warning: blob size %d >= minimum size %d\n",
							fdt32_to_cpu(fdt.totalsize), minsize);
				}
			}

			if (padsize > 0)
				padlen = padsize;

			if (alignsize > 0)
				padlen = ALIGN(fdt32_to_cpu(fdt.totalsize) + padlen, alignsize)
					- fdt32_to_cpu(fdt.totalsize);

			if (padlen > 0) {
				int tsize = fdt32_to_cpu(fdt.totalsize);
				tsize += padlen;
				fdt.totalsize = cpu_to_fdt32(tsize);
			}

			/*
			* Assemble the blob: start with the header, add with alignment
			* the reserve buffer, add the reserve map terminating zeroes,
			* the device tree itself, and finally the strings.
			*/
			blob = data_append_data(blob, &fdt, vi->hdr_size);
			blob = data_append_align(blob, 8);
			blob = data_merge(blob, reservebuf);
			blob = data_append_zeroes(blob, sizeof(struct fdt_reserve_entry));
			blob = data_merge(blob, dtbuf);
			blob = data_merge(blob, strbuf);

			/*
			* If the user asked for more space than is used, pad out the blob.
			*/
			if (padlen > 0)
				blob = data_append_zeroes(blob, padlen);

			if (fwrite(blob.val, blob.len, 1, f) != 1) {
				if (ferror(f))
					die("Error writing device tree blob: %s\n",
						strerror(errno));
				else
					die("Short write on device tree blob\n");
			}

			/*
			* data_merge() frees the right-hand element so only the blob
			* remains to be freed.
			*/
			data_free(blob);
		}

dtb文件结构分析见https://blog.csdn.net/huanting_123/article/details/90142745

### dts的应用

#### dtb加载流程：
1.初始化序列中./common/board_r.c

		static init_fnc_t init_sequence_r[] = {
			initr_trace,
			initr_reloc,
			 ...
			initr_of_live, //加载dts
			#ifdef CONFIG_DM
				initr_dm, //加载dts对应的驱动
			#endif
			...
			run_main_loop,
		};

2.initr_of_live中调用of_live_build

		static int initr_of_live(void)
		{
			if (CONFIG_IS_ENABLED(OF_LIVE)) {
				int ret;

				bootstage_start(BOOTSTAGE_ID_ACCUM_OF_LIVE, "of_live");
				ret = of_live_build(gd->fdt_blob,
							(struct device_node **)gd_of_root_ptr());
				bootstage_accum(BOOTSTAGE_ID_ACCUM_OF_LIVE);
				if (ret)
					return ret;
			}

			return 0;
		}
		

3.of_live_build中调用unflatten_device_tree

		int of_live_build(const void *fdt_blob, struct device_node **rootp)
		{
			int ret;

			debug("%s: start\n", __func__);
			ret = unflatten_device_tree(fdt_blob, rootp);
			if (ret) {
				debug("Failed to create live tree: err=%d\n", ret);
				return ret;
			}
			ret = of_alias_scan();
			if (ret) {
				debug("Failed to scan live tree aliases: err=%d\n", ret);
				return ret;
			}
			debug("%s: stop\n", __func__);

			return ret;
		}
4.unflatten_device_tree加载dts  

		static int unflatten_device_tree(const void *blob,
				 struct device_node **mynodes)
		{
			unsigned long size;
			int start;
			void *mem;

			if (!blob) {
				debug("No device tree pointer\n");initr_dm
			debug("Unflattening device tree:\n");
			debug("magic: %08x\n", fdt_magic(blob));
			debug("size: %08x\n", fdt_totalsize(blob));
			debug("version: %08x\n", fdt_version(blob));

			if (fdt_check_header(blob)) {
				debug("Invalid device tree blob header\n");
				return -EINVAL;
			}

			/* Fiunflatten_device_tree= (unsigned long)unflatten_dt_node(blob, NULL, &start, NULL, NULL,
								0, true);
			if (!size)
				return -EFAULT;
			size = ALIGN(size, 4);

			debug("  size is %lx, allocating...\n", size);

			/* Allocate memory for the expanded device tree */
			mem = malloc(size + 4);
			memunflatten_device_tree
			debug("  unflattening %p...\n", mem);

			/* Second pass, do actual unflattening */
			start = 0;
			unflatten_dt_node(blob, mem, &start, NULL, mynodes, 0, false);
			if (be32_to_cpup(mem + size) != 0xdeadbeef) {
				debug("End of tree marker overwritten: %08x\n",
					be32_to_cpup(mem + size));
				return -ENOSPC;
			}

			debug(" <- unflatten_device_tree()\n");

			return 0;
		}

#### dts查找

下面我们已mx串口驱动为例，分析uboot中驱动使用dts的过程；
dts文件中配置

				serial@2018000 {
					compatible = "fsl,imx6ul-uart", "fsl,imx6q-uart";
					reg = <0x2018000 0x4000>;
					interrupts = <0x0 0x27 0x4>;
					clocks = <0x1 0xc9 0x1 0xca>;
					clock-names = "ipg", "per";
					status = "disabled";
				};

				serial@2020000 {
					compatible = "fsl,imx6ul-uart", "fsl,imx6q-uart";
					reg = <0x2020000 0x4000>;
					interrupts = <0x0 0x1a 0x4>;
					clocks = <0x1 0xbd 0x1 0xbe>;
					clock-names = "ipg", "per";
					status = "okay";
					pinctrl-names = "default";
					pinctrl-0 = <0xb>;
				};
驱动代码中配置

		#if CONFIG_IS_ENABLED(OF_CONTROL)
		static int mxc_serial_of_to_plat(struct udevice *dev)
		{
			struct mxc_serial_plat *plat = dev_get_plat(dev);
			fdt_addr_t addr;

			addr = dev_read_addr(dev);
			if (addr == FDT_ADDR_T_NONE)
				return -EINVAL;

			plat->reg = (struct mxc_uart *)addr;

			plat->use_dte = fdtdec_get_bool(gd->fdt_blob, dev_of_offset(dev),
							"fsl,dte-mode");
			return 0;
		}

		static const struct udevice_id mxc_serial_ids[] = {
			{ .compatible = "fsl,imx21-uart" },
			{ .compatible = "fsl,imx53-uart" },
			{ .compatible = "fsl,imx6sx-uart" },
			{ .compatible = "fsl,imx6ul-uart" },
			{ .compatible = "fsl,imx7d-uart" },
			{ .compatible = "fsl,imx6q-uart" },
			{ }
		};
		#endif

		U_BOOT_DRIVER(serial_mxc) = {
			.name	= "serial_mxc",
			.id	= UCLASS_SERIAL,
		#if CONFIG_IS_ENAgit dBLED(OF_CONTROL)
			.of_match = mxc_serial_ids,
			.of_to_plat = mxc_serial_of_to_plat,
			.plat_auto	= sizeof(struct mxc_serial_plat),
		#endif
			.probe = mxc_serial_probe,
			.ops	= &mxc_serial_ops,
			.flags = DM_FLAG_PRE_RELOC,
		};
		#endif

在uboot启动时，会根据dts中配置加载对应的驱动，具体流程如下：

./common/board_r.c

		static init_fnc_t init_sequence_r[] = {
			...
			initr_of_live,
		#ifdef CONFIG_DM
			initr_dm,
		#endif
			...
		}

		#ifdef CONFIG_DM
		static int initr_dm(void)
		{
			int ret;

			/* Save the pre-reloc driver model and start a new one */
			gd->dm_root_f = gd->dm_root;
			gd->dm_root = NULL;
		#ifdef CONFIG_TIMER
			gd->timer = NULL;
		#endif
			bootstage_start(BOOTSTAGE_ID_ACCUM_DM_R, "dm_r");
			ret = dm_init_and_scan(false);
			bootstage_accum(BOOTSTAGE_ID_ACCUM_DM_R);
			if (ret)
				return ret;

			return 0;
		}
		#endif

drivers/core/root.c

		int dm_init_and_scan(bool pre_reloc_only)
		{
			int ret;

			ret = dm_init(CONFIG_IS_ENABLED(OF_LIVE));
			if (ret) {
				debug("dm_init() failed: %d\n", ret);
				return ret;
			}
			if (!CONFIG_IS_ENABLED(OF_PLATDATA_INST)) {
				ret = dm_scan(pre_reloc_only);
				if (ret) {
					log_debug("dm_scan() failed: %d\n", ret);
					return ret;
				}
			}

			return 0;
		}

		/**
		* dm_scan() - Scan tables to bind devices
		*
		* Runs through the driver_info tables and binds the devices it finds. Then runs
		* through the devicetree nodes. Finally calls dm_scan_other() to add any
		* special devices
		*
		* @pre_reloc_only: If true, bind only nodes with special devicetree properties,
		* or drivers with the DM_FLAG_PRE_RELOC flag. If false bind all drivers.
		*/
		static int dm_scan(bool pre_reloc_only)
		{
			int ret;

			ret = dm_scan_plat(pre_reloc_only);
			if (ret) {
				debug("dm_scan_plat() failed: %d\n", ret);
				return ret;
			}

			if (CONFIG_IS_ENABLED(OF_CONTROL) && !CONFIG_IS_ENABLED(OF_PLATDATA)) {
				ret = dm_extended_scan(pre_reloc_only);
				if (ret) {
					debug("dm_extended_scan() failed: %d\n", ret);
					return ret;
				}
			}

			ret = dm_scan_other(pre_reloc_only);
			if (ret)
				return ret;

			return 0;
		}



		int dm_extended_scan(bool pre_reloc_only)
		{
			int ret, i;
			const char * const nodes[] = {
				"/chosen",
				"/clocks",
				"/firmware"
			};

			ret = dm_scan_fdt(pre_reloc_only);
			if (ret) {
				debug("dm_scan_fdt() failed: %d\n", ret);
				return ret;
			}

			/* Some nodes aren't devices themselves but may contain some */
			for (i = 0; i < ARRAY_SIZE(nodes); i++) {
				ret = dm_scan_fdt_ofnode_path(nodes[i], pre_reloc_only);
				if (ret) {
					debug("dm_scan_fdt() scan for %s failed: %d\n",
						nodes[i], ret);
					return ret;
				}
			}

			return ret;
		}

		int dm_scan_fdt_dev(struct udevice *dev)
		{
			return dm_scan_fdt_node(dev, dev_ofnode(dev),
						gd->flags & GD_FLG_RELOC ? false : true);
		}

		int dm_scan_fdt(bool pre_reloc_only)
		{
			return dm_scan_fdt_node(gd->dm_root, ofnode_root(), pre_reloc_only);
		}

		static int dm_scan_fdt_ofnode_path(const char *path, bool pre_reloc_only)
		{
			ofnode node;

			node = ofnode_path(path);

			return dm_scan_fdt_node(gd->dm_root, node, pre_reloc_only);
		}



		static int dm_scan_fdt_node(struct udevice *parent, ofnode parent_node,
						bool pre_reloc_only)
		{
			int ret = 0, err = 0;
			ofnode node;

			if (!ofnode_valid(parent_node))
				return 0;

			for (node = ofnode_first_subnode(parent_node);
				ofnode_valid(node);
				node = ofnode_next_subnode(node)) {
				const char *node_name = ofnode_get_name(node);

				if (!ofnode_is_enabled(node)) {
					pr_debug("   - ignoring disabled device\n");
					continue;
				}
				err = lists_bind_fdt(parent, node, NULL, pre_reloc_only);
				if (err && !ret) {
					ret = err;
					debug("%s: ret=%d\n", node_name, ret);
				}
			}

			if (ret)
				dm_warn("Some drivers failed to bind\n");

			return ret;
		}

drivers/core/lists.c

		int lists_bind_fdt(struct udevice *parent, ofnode node, struct udevice **devp,
				bool pre_reloc_only)
		{
			struct driver *driver = ll_entry_start(struct driver, driver);
			const int n_ents = ll_entry_count(struct driver, driver);
			const struct udevice_id *id;
			struct driver *entry;
			struct udevice *dev;
			bool found = false;
			const char *name, *compat_list, *compat;
			int compat_length, i;
			int result = 0;
			int ret = 0;

			if (devp)
				*devp = NULL;
			name = ofnode_get_name(node);
			log_debug("bind node %s\n", name);

			compat_list = ofnode_get_property(node, "compatible", &compat_length);
			if (!compat_list) {
				if (compat_length == -FDT_ERR_NOTFOUND) {
					log_debug("Device '%s' has no compatible string\n",
						name);
					return 0;
				}

				dm_warn("Device tree error at node '%s'\n", name);
				return compat_length;
			}

			/*
			* Walk through the compatible string list, attempting to match each
			* compatible string in order such that we match in order of priority
			* from the first string to the last.
			*/
			for (i = 0; i < compat_length; i += strlen(compat) + 1) {
				compat = compat_list + i;
				log_debug("   - attempt to match compatible string '%s'\n",
					compat);

				for (entry = driver; entry != driver + n_ents; entry++) {
					ret = driver_check_compatible(entry->of_match, &id,
									compat);
					if (!ret)
						break;
				}
				if (entry == driver + n_ents)
					continue;

				if (pre_reloc_only) {
					if (!ofnode_pre_reloc(node) &&
						!(entry->flags & DM_FLAG_PRE_RELOC)) {
						log_debug("Skipping device pre-relocation\n");
						return 0;
					}
				}

				log_debug("   - found match at '%s': '%s' matches '%s'\n",
					entry->name, entry->of_match->compatible,
					id->compatible);
				ret = device_bind_with_driver_data(parent, entry, name,
								id->data, node, &dev);
				if (ret == -ENODEV) {
					log_debug("Driver '%s' refuses to bind\n", entry->name);
					continue;
				}
				if (ret) {
					dm_warn("Error binding driver '%s': %d\n", entry->name,
						ret);
					return log_msg_ret("bind", ret);
				} else {
					found = true;
					if (devp)
						*devp = dev;
				}
				break;
			}

			if (!found && !result && ret != -ENODEV)
				log_debug("No match for node '%s'\n", name);

			return result;
		}


		/**
		* driver_check_compatible() - Check if a driver matches a compatible string
		*
		* @param of_match:	List of compatible strings to match
		* @param of_idp:	Returns the match that was found
		* @param compat:	The compatible string to search for
		* @return 0 if there is a match, -ENOENT if no match
		*/
		static int driver_check_compatible(const struct udevice_id *of_match,
						const struct udevice_id **of_idp,
						const char *compat)
		{
			if (!of_match)
				return -ENOENT;

			while (of_match->compatible) {
				if (!strcmp(of_match->compatible, compat)) {
					*of_idp = of_match;
					return 0;
				}
				of_match++;
			}

			return -ENOENT;
		}
### DTO机制
		Device Tree Overlay