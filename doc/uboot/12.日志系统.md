
<!-- TOC -->

- [日志驱动声明](#%E6%97%A5%E5%BF%97%E9%A9%B1%E5%8A%A8%E5%A3%B0%E6%98%8E)
    - [console日志](#console%E6%97%A5%E5%BF%97)
    - [syslog日志](#syslog%E6%97%A5%E5%BF%97)
- [日志驱动初始化](#%E6%97%A5%E5%BF%97%E9%A9%B1%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96)
- [日志打印流程](#%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E6%B5%81%E7%A8%8B)
    - [logxxx](#logxxx)
    - [log](#log)
    - [logdispatch](#logdispatch)

<!-- /TOC -->

# 日志驱动声明

        #define LOG_DRIVER(_name) \
            ll_entry_declare(struct log_driver, _name, log_driver)

查找代码,uboot中声明下下面两个日志驱动

## console日志

    console日志借助printf实现

        static int log_console_emit(struct log_device *ldev, struct log_rec *rec)
        {
            int fmt = gd->log_fmt;
            bool add_space = false;

            /*
            * The output format is designed to give someone a fighting chance of
            * figuring out which field is which:
            *    - level is in CAPS
            *    - cat is lower case and ends with comma
            *    - file normally has a .c extension and ends with a colon
            *    - line is integer and ends with a -
            *    - function is an identifier and ends with ()
            *    - message has a space before it unless it is on its own
            */
            if (!(rec->flags & LOGRECF_CONT) && fmt != BIT(LOGF_MSG)) {
                add_space = true;
                if (fmt & BIT(LOGF_LEVEL))
                    printf("%s.", log_get_level_name(rec->level));
                if (fmt & BIT(LOGF_CAT))
                    printf("%s,", log_get_cat_name(rec->cat));
                if (fmt & BIT(LOGF_FILE))
                    printf("%s:", rec->file);
                if (fmt & BIT(LOGF_LINE))
                    printf("%d-", rec->line);
                if (fmt & BIT(LOGF_FUNC))
                    printf("%*s()", CONFIG_LOGF_FUNC_PAD, rec->func);
            }
            if (fmt & BIT(LOGF_MSG))
                printf("%s%s", add_space ? " " : "", rec->msg);

            return 0;
        }

        LOG_DRIVER(console) = {
            .name	= "console",
            .emit	= log_console_emit,
            .flags	= LOGDF_ENABLE,
        };

## syslog日志

syslog日志借助网络广播实现，具体见log_syslog_emit  

        #define BUFFER_SIZE 480

        static void append(char **buf, char *buf_end, const char *fmt, ...)
        {
            va_list args;
            size_t size = buf_end - *buf;

            va_start(args, fmt);
            vsnprintf(*buf, size, fmt, args);
            va_end(args);
            *buf += strlen(*buf);
        }

        static int log_syslog_emit(struct log_device *ldev, struct log_rec *rec)
        {
            int ret;
            int fmt = gd->log_fmt;
            char msg[BUFFER_SIZE];
            char *msg_end = msg + BUFFER_SIZE;
            char *ptr = msg;
            char *iphdr;
            char *log_msg;
            int eth_hdr_size;
            struct in_addr bcast_ip;
            unsigned int log_level;
            char *log_hostname;

            /* Setup packet buffers */
            ret = net_init();
            if (ret)
                return ret;
            /* Disable hardware and put it into the reset state */
            eth_halt();
            /* Set current device according to environment variables */
            eth_set_current();
            /* Get hardware ready for send and receive operations */
            ret = eth_init();
            if (ret < 0) {
                eth_halt();
                goto out;
            }

            memset(msg, 0, BUFFER_SIZE);

            /* Set ethernet header */
            eth_hdr_size = net_set_ether((uchar *)ptr, net_bcast_ethaddr, PROT_IP);
            ptr += eth_hdr_size;
            iphdr = ptr;
            ptr += IP_UDP_HDR_SIZE;
            log_msg = ptr;

            /*
            * The syslog log levels defined in RFC 5424 match the U-Boot ones up to
            * level 7 (debug).
            */
            log_level = rec->level;
            if (log_level > 7)
                log_level = 7;
            /* Leave high bits as 0 to write a 'kernel message' */

            /* Write log message to buffer */
            append(&ptr, msg_end, "<%u>", log_level);
            log_hostname = env_get("log_hostname");
            if (log_hostname)
                append(&ptr, msg_end, "%s ", log_hostname);
            append(&ptr, msg_end, "uboot: ");
            if (fmt & BIT(LOGF_LEVEL))
                append(&ptr, msg_end, "%s.",
                    log_get_level_name(rec->level));
            if (fmt & BIT(LOGF_CAT))
                append(&ptr, msg_end, "%s,",
                    log_get_cat_name(rec->cat));
            if (fmt & BIT(LOGF_FILE))
                append(&ptr, msg_end, "%s:", rec->file);
            if (fmt & BIT(LOGF_LINE))
                append(&ptr, msg_end, "%d-", rec->line);
            if (fmt & BIT(LOGF_FUNC))
                append(&ptr, msg_end, "%s()", rec->func);
            if (fmt & BIT(LOGF_MSG))
                append(&ptr, msg_end, "%s%s",
                    fmt != BIT(LOGF_MSG) ? " " : "", rec->msg);
            /* Consider trailing 0x00 */
            ptr++;

            debug("log message: '%s'\n", log_msg);

            /* Broadcast message */
            bcast_ip.s_addr = 0xFFFFFFFFL;
            net_set_udp_header((uchar *)iphdr, bcast_ip, 514, 514, ptr - log_msg);
            net_send_packet((uchar *)msg, ptr - msg);

        out:
            return ret;
        }

        LOG_DRIVER(syslog) = {
            .name	= "syslog",
            .emit	= log_syslog_emit,
        };

看声明，只有console日志系统被使能了；

# 日志驱动初始化

在uboot启动过程中，会调用log_init,初始化日志驱动

        int log_init(void)
        {
            struct log_driver *drv = ll_entry_start(struct log_driver, log_driver);
            const int count = ll_entry_count(struct log_driver, log_driver);
            struct log_driver *end = drv + count;

            /*
            * We cannot add runtime data to the driver since it is likely stored
            * in rodata. Instead, set up a 'device' corresponding to each driver.
            * We only support having a single device.
            */
            INIT_LIST_HEAD((struct list_head *)&gd->log_head);
            while (drv < end) {
                struct log_device *ldev;

                ldev = calloc(1, sizeof(*ldev));
                if (!ldev) {
                    debug("%s: Cannot allocate memory\n", __func__);
                    return -ENOMEM;
                }
                INIT_LIST_HEAD(&ldev->filter_head);
                ldev->drv = drv;
                ldev->flags = drv->flags;
                list_add_tail(&ldev->sibling_node,
                        (struct list_head *)&gd->log_head);
                drv++;
            }
            gd->flags |= GD_FLG_LOG_READY;
            if (!gd->default_log_level)
                gd->default_log_level = CONFIG_LOG_DEFAULT_LEVEL;
            gd->log_fmt = log_get_default_format();
            gd->logc_prev = LOGC_NONE;
            gd->logl_prev = LOGL_INFO;

            return 0;
        }

# 日志打印流程

## log_xxx
    打印日志时，使用log宏，宏定义如下：

        #define log_emer(_fmt...)	log(LOG_CATEGORY, LOGL_EMERG, ##_fmt)
        #define log_alert(_fmt...)	log(LOG_CATEGORY, LOGL_ALERT, ##_fmt)
        #define log_crit(_fmt...)	log(LOG_CATEGORY, LOGL_CRIT, ##_fmt)
        #define log_err(_fmt...)	log(LOG_CATEGORY, LOGL_ERR, ##_fmt)
        #define log_warning(_fmt...)	log(LOG_CATEGORY, LOGL_WARNING, ##_fmt)
        #define log_notice(_fmt...)	log(LOG_CATEGORY, LOGL_NOTICE, ##_fmt)
        #define log_info(_fmt...)	log(LOG_CATEGORY, LOGL_INFO, ##_fmt)
        #define log_debug(_fmt...)	log(LOG_CATEGORY, LOGL_DEBUG, ##_fmt)
        #define log_content(_fmt...)	log(LOG_CATEGORY, LOGL_DEBUG_CONTENT, ##_fmt)
        #define log_io(_fmt...)		log(LOG_CATEGORY, LOGL_DEBUG_IO, ##_fmt)
        #define log_cont(_fmt...)	log(LOGC_CONT, LOGL_CONT, ##_fmt)

        /* Emit a log record if the level is less that the maximum */
        #define log(_cat, _level, _fmt, _args...) ({ \
            int _l = _level; \
            if (_LOG_DEBUG != 0 || _l <= _LOG_MAX_LEVEL) \
                _log((enum log_category_t)(_cat), \
                    (enum log_level_t)(_l | _LOG_DEBUG), __FILE__, \
                    __LINE__, __func__, \
                    pr_fmt(_fmt), ##_args); \
            })

## _log

    _log函数中调用log_dispatch分发日志数据

        int _log(enum log_category_t cat, enum log_level_t level, const char *file,
            int line, const char *func, const char *fmt, ...)
        {
            struct log_rec rec;
            va_list args;

            if (!gd)
                return -ENOSYS;

            /* Check for message continuation */
            if (cat == LOGC_CONT)
                cat = gd->logc_prev;
            if (level == LOGL_CONT)
                level = gd->logl_prev;

            rec.cat = cat;
            rec.level = level & LOGL_LEVEL_MASK;
            rec.flags = 0;
            if (level & LOGL_FORCE_DEBUG)
                rec.flags |= LOGRECF_FORCE_DEBUG;
            if (gd->log_cont)
                rec.flags |= LOGRECF_CONT;
            rec.file = file;
            rec.line = line;
            rec.func = func;
            rec.msg = NULL;

            if (!(gd->flags & GD_FLG_LOG_READY)) {
                gd->log_drop_count++;

                /* display dropped traces with console puts and DEBUG_UART */
                if (rec.level <= CONFIG_LOG_DEFAULT_LEVEL ||
                    rec.flags & LOGRECF_FORCE_DEBUG) {
                    char buf[CONFIG_SYS_CBSIZE];

                    va_start(args, fmt);
                    vsnprintf(buf, sizeof(buf), fmt, args);
                    puts(buf);
                    va_end(args);
                }

                return -ENOSYS;
            }
            va_start(args, fmt);
            if (!log_dispatch(&rec, fmt, args)) {
                gd->logc_prev = cat;
                gd->logl_prev = level;
            }
            va_end(args);

            return 0;
        }

## log_dispatch
    log_dispatch通过调用log_driver的emit接口，将数据交给各个driver处理

        /**
        * log_dispatch() - Send a log record to all log devices for processing
        *
        * The log record is sent to each log device in turn, skipping those which have
        * filters which block the record.
        *
        * All log messages created while processing log record @rec are ignored.
        *
        * @rec:	log record to dispatch
        * Return:	0 msg sent, 1 msg not sent while already dispatching another msg
        */
        static int log_dispatch(struct log_rec *rec, const char *fmt, va_list args)
        {
            struct log_device *ldev;
            char buf[CONFIG_SYS_CBSIZE];

            /*
            * When a log driver writes messages (e.g. via the network stack) this
            * may result in further generated messages. We cannot process them here
            * as this might result in infinite recursion.
            */
            if (gd->processing_msg)
                return 1;

            /* Emit message */
            gd->processing_msg = true;
            list_for_each_entry(ldev, &gd->log_head, sibling_node) {
                if ((ldev->flags & LOGDF_ENABLE) &&
                    log_passes_filters(ldev, rec)) {
                    if (!rec->msg) {
                        int len;

                        len = vsnprintf(buf, sizeof(buf), fmt, args);
                        rec->msg = buf;
                        gd->log_cont = len && buf[len - 1] != '\n';
                    }
                    ldev->drv->emit(ldev, rec);
                }
            }
            gd->processing_msg = false;
            return 0;
        }

       